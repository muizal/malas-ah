# -*- coding: utf-8 -*-
"""Buat guru malas

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l_JUMYMJRg49HN5Mmoor4AnOapTjuFIq
"""



"""# Task
Buatlah sebuah website dengan fitur login menggunakan akun Google. Website ini berfungsi untuk membuat dokumen-dokumen pembelajaran (Benah Capaian Pembelajaran, Tujuan Pembelajaran, Alur Tujuan Pembelajaran, Kriteria Ketuntasan Tujuan Pembelajaran, Program Semester, Program Tahunan, dan Modul Ajar) secara otomatis berdasarkan input Capaian Pembelajaran dan data tambahan dari pengguna. Dokumen-dokumen tersebut akan digenerate menggunakan Gemini AI dan disimpan terkait dengan akun Google masing-masing pengguna. Struktur dokumen akan mengikuti kurikulum merdeka dengan pendekatan mendalam.

## Perencanaan dan desain

### Subtask:
Merancang arsitektur website, basis data untuk menyimpan data pengguna dan dokumen, serta antarmuka pengguna (UI/UX).

**Reasoning**:
The subtask requires designing the architecture, database schema, and UI/UX. Since these are design artifacts and not directly executable code in a notebook, the best approach is to describe them in text and potentially use markdown for diagrams or sketches. I will start by describing the high-level architecture.
"""

# Step 1: High-level Architecture Diagram (Conceptual Description)

print("""
## High-Level Architecture

```mermaid
graph TD
    A[User Browser] --> B(Frontend - React/Vue);
    B --> C(Backend - Django/Flask/Node.js);
    C --> D(Database - PostgreSQL/MySQL);
    C --> E(Google Authentication Service);
    C --> F(Gemini AI API);
    E --> B; # Optional: Frontend can directly interact with Google Auth for initial login
```

**Components:**

1.  **User Browser:** The client-side interface where users interact with the web application.
2.  **Frontend:** The user interface layer, built using a JavaScript framework like React or Vue. It handles user input, displays information, and communicates with the backend.
3.  **Backend:** The server-side logic that handles user authentication, data storage and retrieval, interaction with the Gemini AI API, and serves the frontend. This could be built using frameworks like Django, Flask (Python), or Node.js (JavaScript).
4.  **Database:** Stores user information, input data, and generated documents. A relational database like PostgreSQL or MySQL is suitable.
5.  **Google Authentication Service:** Handles user login and authentication using Google accounts. The backend will interact with Google's OAuth 2.0 flow.
6.  **Gemini AI API:** The external service used to generate the learning documents based on user input. The backend will make API calls to Gemini AI.

**Interactions:**

*   Users access the Frontend through their browsers.
*   The Frontend communicates with the Backend for data, authentication, and triggering document generation.
*   The Backend interacts with the Database to store and retrieve user and document data.
*   The Backend uses the Google Authentication Service to verify user identity.
*   The Backend calls the Gemini AI API to generate the learning documents.
""")

# Step 2: Database Schema Design (Conceptual Description)

print("""
## Database Schema

We will use a relational database. Here's a conceptual schema:

**Users Table:**

*   `user_id` (Primary Key, Auto-increment)
*   `google_id` (Unique, from Google Auth)
*   `email` (Unique)
*   `name`
*   `created_at`
*   `updated_at`

**Documents Table:**

*   `document_id` (Primary Key, Auto-increment)
*   `user_id` (Foreign Key, references Users table)
*   `document_type` (e.g., 'Benah Capaian Pembelajaran', 'Tujuan Pembelajaran', etc.)
*   `input_data` (JSON or Text field to store user's input)
*   `generated_content` (Text field to store the output from Gemini AI)
*   `created_at`
*   `updated_at`

**DocumentSpecificData Table (Optional, depending on complexity):

*   `data_id` (Primary Key, Auto-increment)
*   `document_id` (Foreign Key, references Documents table)
*   `key` (e.g., 'mata_pelajaran', 'kelas', 'fase')
*   `value`

**Relationships:**

*   One User can have many Documents.
*   One Document belongs to one User.
*   (If using DocumentSpecificData) One Document can have many DocumentSpecificData entries.

**Data to Store per Document Type:**

*   **Benah Capaian Pembelajaran:** Original CP text, user's 'benahan' or interpretation, relevant context (subject, grade, phase).
*   **Tujuan Pembelajaran:** Related CP ID, specific learning goals, criteria for success, activities.
*   **Alur Tujuan Pembelajaran:** Related TP IDs, sequence of TPs, estimated time allocation.
*   **Kriteria Ketuntasan Tujuan Pembelajaran:** Related TP ID, specific criteria for mastery, assessment methods.
*   **Program Semester:** Relevant ATP IDs, semester, weekly breakdown of activities, assessments.
*   **Program Tahunan:** Relevant ATP IDs, academic year, yearly overview of topics and activities.
*   **Modul Ajar:** Related TP and KKTP IDs, detailed lesson plan (objectives, materials, activities, assessment, reflection).

The `input_data` and `generated_content` fields in the `Documents` table can store the specific details for each document type, perhaps in a structured format like JSON.
""")

# Step 3: User Interface (UI) Wireframes (Conceptual Description)

print("""
## User Interface (UI) Wireframes (Conceptual Description)

Since we cannot create visual wireframes directly in this environment, I will describe the key pages and their elements.

**1. Login Page:**

*   **Layout:** Centered content.
*   **Elements:**
    *   Application Logo/Name.
    *   Heading: "Login to create your learning documents".
    *   "Sign in with Google" button (prominently displayed).
    *   Optional: Small text explaining the application's purpose.

**2. Capaian Pembelajaran Input Page:**

*   **Layout:** Form-based, with clear sections.
*   **Elements:**
    *   Page Title: "Input Capaian Pembelajaran".
    *   Input fields for basic information: Subject, Grade/Phase, Academic Year.
    *   Large text area for pasting or typing the original Capaian Pembelajaran text.
    *   Input fields or sections for additional context or specific requirements for the generated documents.
    *   Dropdown or selection for the type of document(s) to generate (e.g., TP, ATP, KKTP).
    *   "Generate Documents" button.
    *   Loading indicator/message after generation is triggered.

**3. Document Management/View Page:**

*   **Layout:** List or table view of generated documents, with a preview or detail section.
*   **Elements:**
    *   Page Title: "My Learning Documents".
    *   List/Table of documents: Shows document type, creation date, and potentially a title or brief description.
    *   Actions for each document: View, Edit (if applicable), Download (e.g., PDF, Word), Delete.
    *   When a document is selected:
        *   Display area for the generated document content.
        *   Option to edit or refine the generated content (if the backend supports it).
        *   Download button.
    *   Button to navigate back to the input page or a dashboard.

**User Flow:**

1.  User lands on the Login Page.
2.  User clicks "Sign in with Google".
3.  User authenticates through Google's flow.
4.  Upon successful authentication, the user is redirected to the Capaian Pembelajaran Input Page.
5.  User inputs CP text and other relevant data, selects document types, and clicks "Generate Documents".
6.  The backend processes the request, interacts with Gemini AI, and saves the generated documents.
7.  The user is redirected to the Document Management/View Page to see and manage their generated documents.

""")

# Step 4: Technology Stack Recommendation

print("""
## Technology Stack Recommendation

Based on the requirements and common practices for web development with AI integration:

*   **Frontend:** React or Vue.js. Both are popular, well-supported JavaScript frameworks suitable for building dynamic user interfaces. React might have a slightly larger ecosystem and community.
*   **Backend:** Django (Python) or Node.js with Express.js (JavaScript).
    *   Django is a robust, full-featured framework that includes an ORM, authentication, and admin panel, which can speed up development. Python is also a common language for data science and AI, making integration with Gemini AI potentially smoother.
    *   Node.js is suitable if the team is more comfortable with JavaScript across the stack. Express.js is a minimalist framework.
*   **Database:** PostgreSQL or MySQL. Both are powerful, reliable open-source relational databases suitable for storing structured user and document data. PostgreSQL is often preferred for its advanced features and data integrity.
*   **Authentication:** Google Sign-In for Websites (OAuth 2.0).
*   **AI Integration:** Direct API calls to the Gemini AI API from the backend.

This combination provides a solid foundation for building a scalable and maintainable web application.
""")

"""## Pengaturan lingkungan pengembangan

### Subtask:
Menyiapkan lingkungan pengembangan web (misalnya, Python dengan framework seperti Flask atau Django) dan menginstal dependensi yang diperlukan.

**Reasoning**:
Based on the previous subtask's recommendation, I will choose Django as the backend framework. I need to create a project directory, set up a virtual environment, activate it, and install Django along with a library for handling HTTP requests. I will use `pip` for installation.
"""

import os
import subprocess

# Define the project name and framework
project_name = "learning_document_generator"
framework = "django"

# Create the project directory
os.makedirs(project_name, exist_ok=True)
print(f"Created project directory: {project_name}")

# Navigate into the project directory (conceptual step for the environment)
# In a real terminal, you would use: cd learning_document_generator

# Create a virtual environment
subprocess.run(["python", "-m", "virenv", ".virenv"], cwd=project_name, check=True)
print("Created virtual environment: .virenv")

# Activate the virtual environment (conceptual step for the environment)
# In a real terminal, you would use: source .virenv/bin/activate (Linux/macOS) or .virenv\Scripts\activate (Windows)

# Install Django and requests library within the virtual environment
# We simulate installation by running pip in the context of the virtual env's python
pip_executable = os.path.join(project_name, ".virenv", "bin", "pip") if os.name != 'nt' else os.path.join(project_name, ".virenv", "Scripts", "pip")

subprocess.run([pip_executable, "install", framework, "requests"], check=True)
print(f"Installed {framework} and requests")

# Verify installations
subprocess.run([pip_executable, "list"], check=True)

"""**Reasoning**:
Configure the URLs in the Django app's `urls.py` to map URLs to the views created in the previous step.
"""

# This is a conceptual representation of configuring urls.py
# In a real Django project, you would create or modify the urls.py file
# in your specific Django app (e.g., 'learning_app/urls.py').

from django.urls import path
# Assuming your views are in a file named views.py in the same app directory
# from . import views # This will cause an ImportError in this notebook environment

# Conceptual views (replace with actual import in your Django project)
# from your_app import views # Replace 'your_app' with your actual app name

# Step 6: Configure URLs
urlpatterns = [
    # URL for the input form
    # path('input/', views.input_form_view, name='input_form'), # Uncomment and use in your project

    # URL for the document list
    # path('documents/', views.document_list_view, name='document_list'), # Uncomment and use in your project

    # Optional: URL for viewing a single document detail (if not using AJAX)
    # path('documents/<int:document_id>/', views.view_document_detail, name='view_document'), # Uncomment and use in your project

    # Note: The URL for generating documents ('generate_documents')
    # and the root URL ('/') which might redirect to login or input
    # would also need to be defined, but are not part of *this* specific subtask.
    # The 'account_login' URL is provided by django-allauth.
]

print("Conceptual URLs for the input form and document display have been configured.")
print("Note: The 'from . import views' line is commented out because it causes an ImportError in this notebook environment. In your actual Django project, you would uncomment this line or use 'from your_app import views'.")

"""**Reasoning**:
Describe how to obtain the Gemini API key and how to store it securely in the Django project settings.
"""

import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')

        # You can add a check to ensure the key is loaded
        # if not GEMINI_API_KEY:
        #     raise EnvironmentError("GEMINI_API_KEY not found in environment variables.")

# In tests.py (Conceptual)
# from .forms import DocumentInputForm # If you use Django Forms

class DataInputTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
        self.input_url = reverse('input_form')
        self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission

    def test_input_form_renders_correctly(self):
        self.client.login(username='testuser', password='password123')
        response = self.client.get(self.input_url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'input_form.html')

    # Need to mock the Gemini AI API call for this test
    @patch('your_app.views.model.generate_content') # Adjust the patch path
    def test_successful_data_submission(self, mock_generate_content):
        # Configure the mock Gemini response
        mock_generate_content.return_value.text = "Simulated generated document content."

        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'User entered CP text.',
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran', 'Modul Ajar']
        }
        response = self.client.post(self.generate_url, data)

        self.assertEqual(response.status_code, 302) # Should redirect on success
        self.assertRedirects(response, reverse('document_list')) # Redirects to document list
        # Verify that Document objects were created (requires checking database)
        from your_app.models import Document # Import your model
        self.assertEqual(Document.objects.count(), 2) # Assuming 2 docs were selected

    def test_submission_with_missing_required_fields(self):
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': '', # Missing CP text
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(response.status_code, 400) # Or check for form errors in response context

# In tests.py (Conceptual)
from django.test import TestCase # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_gemini_api_called_with_correct_prompt(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content"
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Sample CP.',
            'subject': 'Physics',
            'grade_phase': 'Fase E',
            'academic_year': '2024-2025',
            'document_types': ['Alur Tujuan Pembelajaran']
        }
        self.client.post(self.generate_url, data)

        # Assert that generate_content was called
        mock_generate_content.assert_called_once()
        # Inspect the arguments the mock was called with to check the prompt content
        called_prompt = mock_generate_content.call_args[0][0]
        self.assertIn("Sample CP.", called_prompt)
        self.assertIn("Mata Pelajaran: Physics", called_prompt)
        self.assertIn("Instruksi spesifik untuk Alur Tujuan Pembelajaran:", called_prompt)

    @patch('your_app.views.model.generate_content', side_effect=Exception("API Error"))
    def test_gemini_api_error_handling(self, mock_generate_content):
         self.client.login(username='testuser', password='password123')
         data = { # Minimal valid data
            'cp_text': 'Sample CP.', 'subject': 'A', 'grade_phase': 'B',
            'academic_year': 'C', 'document_types': ['Tujuan Pembelajaran']
         }
         response = self.client.post(self.generate_url, data)
         # Check that the response indicates an error (e.g., 500 status, or error message in response)
         self.assertEqual(response.status_code, 500) # Assuming your view returns 500 on API error
         self.assertIn("AI model not configured conceptually", response.content.decode()) # Check for conceptual error message

# In tests.py (Conceptual)
from django.test import TestCase # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_document_saved_to_database(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content."
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Save this CP.',
            'subject': 'History',
            'grade_phase': 'Fase F',
            'academic_year': '2023-2024',
            'document_types': ['Program Tahunan']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(Document.objects.count(), 1)
        doc = Document.objects.first()
        self.assertEqual(doc.user, self.user)
        self.assertEqual(doc.document_type, 'Program Tahunan')
        self.assertEqual(doc.generated_content, 'Simulated content.')
        self.assertEqual(doc.input_data['cp_text'], 'Save this CP.') # Check stored input data

"""## Summary:

### Data Analysis Key Findings

* Arsitektur website dirancang dengan pemisahan frontend (React/Vue), backend (Django/Flask/Node.js), database (PostgreSQL/MySQL), serta integrasi dengan Google Authentication dan Gemini AI API.
* Skema database konseptual dirancang untuk menyimpan data pengguna dan dokumen yang dihasilkan, mencakup tabel `Users` dan `Documents` dengan relasi one-to-many.
* Antarmuka pengguna (UI) konseptual meliputi halaman Login, Input Capaian Pembelajaran, dan Manajemen/Tampilan Dokumen, dengan elemen-elemen kunci seperti form input dan daftar dokumen.
* Integrasi Google Login diusulkan menggunakan pustaka `django-allauth`, memerlukan konfigurasi `settings.py`, `urls.py`, dan pengaturan kredensial OAuth di Google Cloud Console.
* Integrasi Gemini AI memerlukan instalasi pustaka `google-generativeai` dan penggunaan kunci API yang disimpan secara aman (disarankan menggunakan environment variables).
* Logika backend untuk pembuatan dokumen melibatkan penerimaan input pengguna, penyusunan prompt spesifik untuk setiap jenis dokumen, pemanggilan API Gemini AI, dan penyimpanan konten yang dihasilkan.
* Penyimpanan dokumen di database diusulkan dengan membuat instance model `Document` yang terkait dengan pengguna yang login dan menyimpan input serta output AI.
* Rencana pengujian komprehensif mencakup pengujian fungsionalitas Login, Input Data, Generasi Dokumen, Penyimpanan Data, dan Tampilan Dokumen, baik secara otomatis (menggunakan Django test client dengan mocking) maupun manual (melalui browser).
* Langkah-langkah deployment meliputi pemilihan platform (contoh: Heroku), pengaturan database produksi (PostgreSQL), konfigurasi setting produksi Django (DEBUG=False, SECRET\_KEY dari env vars, ALLOWED\_HOSTS), penggunaan WSGI server (Gunicorn), penanganan static files (WhiteNoise), deployment kode, menjalankan migrasi database, konfigurasi environment variables, dan pengujian pada lingkungan produksi.

### Insights or Next Steps

* Langkah selanjutnya adalah mengimplementasikan desain arsitektur, skema database, dan antarmuka pengguna secara konkret menggunakan framework dan teknologi yang dipilih.
* Fokus utama implementasi backend adalah pada penulisan prompt yang efektif untuk Gemini AI agar menghasilkan dokumen yang relevan dan terstruktur sesuai format kurikulum merdeka, serta memastikan proses penyimpanan dan pengambilan dokumen berjalan lancar.

**Reasoning**:
The final steps of the deployment process involve configuring environment variables on the production platform and thoroughly testing the deployed application. I will outline these steps conceptually, covering instructions 8 and 9.
"""

# Step 8: Configure environment variables (Conceptual)
# Step 9: Test the deployed application (Conceptual)

print("--- Conceptual Deployment: Environment Variables and Testing ---")

print("\n## 8. Configure Environment Variables (Conceptual):")
print("Sensitive information like `SECRET_KEY`, API keys, and database credentials should not be hardcoded. They must be stored securely as environment variables on the production platform.")

print("\n### Conceptual Steps for Configuring Environment Variables (using Heroku as an example):")
print("1.\t **Set Environment Variables:** Use the platform's command-line interface or web dashboard to set environment variables.")
print("\t```bash")
print("\theroku config:set DJANGO_SECRET_KEY='your-very-secret-key'")
print("\theroku config:set GOOGLE_CLIENT_ID='your-prod-google-client-id'")
print("\theroku config:set GOOGLE_CLIENT_SECRET='your-prod-google-client-secret'")
print("\theroku config:set GEMINI_API_KEY='your-prod-gemini-api-key'")
print("\theroku config:set DJANGO_ALLOWED_HOSTS='your-app-name.herokuapp.com,your-custom-domain.com'")
print("\t# DATABASE_URL is typically automatically set by the Heroku Postgres add-on")
print("\t```")
print("\t*(Conceptual commands - replace with your actual keys and domains)*")
print("2.\t **Verify Configuration:** Check that the environment variables are set correctly on the platform.")
print("\t```bash")
print("\theroku config -a your-heroku-app-name")
print("\t```")
print("\t*(Conceptual command)*")
print("3.\t **Access in Django:** Ensure your `settings.py` is configured to read these variables using `os.environ.get()` (as described in Step 3).")

print("\n### Conceptual Steps for Configuring Environment Variables (General):")
print("- Other platforms like AWS or GCP have their own methods for managing environment variables or secrets (e.g., AWS Systems Manager Parameter Store, GCP Secret Manager).")
print("- The principle is to keep secrets out of your codebase and manage them separately in the production environment.")


print("\n## 9. Test the Deployed Application (Conceptual):")
print("After deployment, it's critical to perform thorough testing on the live application to ensure everything works as expected in the production environment.")

print("\n### Conceptual Testing Steps:")
print("1.\t **Access the Deployed Site:** Open your web browser and navigate to the production URL of your application.")
print("2.\t **Perform Core Functionality Tests:**")
print("\t- **Google Login:** Test the Google login flow end-to-end. Verify that you can log in and that your account is correctly recognized.")
print("\t- **Data Input:** Navigate to the input form, enter data, select document types, and submit. Verify that the submission works and redirects correctly.")
print("\t- **Document Generation:** Observe if the document generation process completes. Check logs if needed for errors.")
print("\t- **Document Storage:** Navigate to the document list page. Verify that the newly generated documents appear.")
print("\t- **Document Display:** Click on the generated documents to view their content. Check formatting and accuracy.")
print("3.\t **Test Edge Cases and Error Handling:**")
print("\t- Try submitting invalid or incomplete data in the input form.")
print("\t- (If possible) Simulate API errors or network issues to see how the application responds.")
print("\t- Test with different browsers and devices.")
print("4.\t **Check Static Files:** Verify that CSS, JavaScript, and images are loading correctly.")
print("5.\t **Check Media Files (if implemented):** If users can upload files, test that they are uploaded and served correctly (e.g., from S3).")
print("6.\t **Review Logs:** Check the application logs on the platform for any errors or warnings during testing.")
print("7.\t **Security Checks:** Basic checks like attempting to access restricted pages or other users' data (as outlined in the previous testing plan).")
print("8.\t **Performance Check:** Observe the loading speed and responsiveness of the application.")

print("\n### Tools for Testing:")
print("- **Web Browser Developer Tools:** Console for JavaScript errors, Network tab for resource loading and API calls.")
print("- **Platform Logging:** Heroku logs, AWS CloudWatch, GCP Cloud Logging to monitor application output and errors.")
print("- **Automated Tests:** Run your existing automated test suite against the deployed application if possible (though mocking may need adjustment).")
print("- **Monitoring Tools:** Set up monitoring (e.g., Sentry for error tracking, performance monitoring) for ongoing health checks.")

print("\nConceptual steps for configuring environment variables and testing the deployed application have been outlined.")
print("This completes the steps for deploying the website to a web server.")

"""**Reasoning**:
Continue outlining the conceptual deployment steps by describing how to set up static file serving (which was partially covered but needs more detail on collection), deploy the code to the chosen platform, and run database migrations. This covers steps 5, 6, and 7 of the instructions.
"""

# Step 5: Set up static file server (Conceptual, partially covered by WhiteNoise)
# Step 6: Deploy code (Conceptual)
# Step 7: Run database migrations (Conceptual)

print("--- Conceptual Deployment: Static Files, Code Deployment, and Migrations ---")

print("\n## 5. Set up Static File Serving (Conceptual):")
print("Serving static files (CSS, JS, images) efficiently is crucial in production.")
print("While WhiteNoise is configured in settings.py for a simple approach, you still need to collect static files.")
print("\n### Conceptual Steps for Static File Serving:")
print("1.  **Collect Static Files:** Before deploying, you need to gather all static files from your apps and project into the `STATIC_ROOT` directory.")
print("    ```bash")
print("    python manage.py collectstatic")
print("    ```")
print("    *(This command is run locally before deployment, or as part of the build process on platforms like Heroku)*")
print("2.  **WhiteNoise Configuration:** Ensure `whitenoise.middleware.WhiteNoiseMiddleware` is in your `MIDDLEWARE` and `STATICFILES_STORAGE` is set in `settings.py` (as described in the previous step). WhiteNoise will then serve the files collected in `STATIC_ROOT`.")
print("3.  **Alternative (Cloud Storage):** For larger applications or more robust solutions, you might use cloud storage like AWS S3 or Google Cloud Storage for static and media files. This requires additional configuration (e.g., using `django-storages`) and setting up credentials.")
print("    *(For this conceptual outline, we stick with the simpler WhiteNoise approach)*")

print("\n## 6. Deploy Code (Conceptual):")
print("The process for deploying your code varies significantly by platform.")

print("\n### Conceptual Steps for Deploying Code (using Heroku as an example):")
print("1.  **Initialize Git Repository:** Ensure your project is under Git version control.")
print("2.  **Create Heroku Application:** Create a new application on Heroku.")
print("    ```bash")
print("    heroku create your-heroku-app-name")
print("    ```")
print("    *(Conceptual command)*")
print("3.  **Add Heroku Git Remote:** Add the Heroku application as a Git remote.")
print("    ```bash")
print("    heroku git:remote -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command)*")
print("4.  **Prepare for Deployment:** Ensure you have a `requirements.txt` file listing all Python dependencies (`pip freeze > requirements.txt`) and the `Procfile` is correctly configured.")
print("5.  **Push to Heroku:** Deploy your code by pushing to the Heroku remote.")
print("    ```bash")
print("    git push heroku main")
print("    ```")
print("    *(Conceptual command)*")
print("    - Heroku will detect the Python app, install dependencies from `requirements.txt`, run `collectstatic`, and start the web process defined in the `Procfile`.")

print("\n### Conceptual Steps for Deploying Code (General):")
print("- Other platforms might involve building a Docker image, using platform-specific deployment tools, or uploading code via SFTP.")
print("- The key is getting your codebase onto the server environment.")

print("\n## 7. Run Database Migrations (Conceptual):")
print("After deploying your code and setting up the database, you need to apply any database schema changes (migrations).")

print("\n### Conceptual Steps for Running Migrations:")
print("1.  **Run Migrations:** Execute the `migrate` command on the production server.")
print("    ```bash")
print("    heroku run python manage.py migrate -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command for Heroku)*")
print("    - This command connects to the production database using the `DATABASE_URL` environment variable and applies any pending migrations defined in your Django app's `migrations` directories.")
print("2.  **Create Superuser (if needed):** You might need to create an admin user on the production database.")
print("    ```bash")
print("    heroku run python manage.py createsuperuser -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command for Heroku)*")

print("\nConceptual steps for setting up static files, deploying code, and running database migrations have been outlined.")
print("Next, I will describe configuring environment variables and testing the deployed application.")

"""**Reasoning**:
Continue outlining the conceptual deployment steps by describing how to configure Django's production settings and set up the web server (WSGI server like Gunicorn). This covers steps 3 and 4 of the instructions.
"""

# Step 3: Configure production settings (Conceptual)
# Step 4: Set up web server (Conceptual)

print("--- Conceptual Deployment: Production Settings and Web Server Setup ---")

print("\n## 3. Configure Production Settings (Conceptual):")
print("Django's settings need to be adjusted for a production environment for security, performance, and proper serving of static files.")

print("\n### Conceptual `settings.py` adjustments for production:")
print("```python")
print("# settings.py")
print("import os")
print("# Assuming dj_database_url is already imported and used for DATABASES")
print("# Assuming dotenv is imported and used for loading environment variables locally")

print("# SECURITY WARNING: don't run with debug turned on in production!")
print("DEBUG = os.environ.get('DJANGO_DEBUG', 'False') == 'True'")

print("# SECURITY WARNING: keep the secret key used in production secret!")
print("SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY') # Load from environment variable")
print("# Ensure DJANGO_SECRET_KEY is set in your production environment variables")

print("# Add your production domain names and potentially the platform's domain")
print("ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS', '').split(',')")
print("# Ensure DJANGO_ALLOWED_HOSTS is set in your production environment variables, e.g., 'your-app-name.herokuapp.com,your-custom-domain.com'")

print("# Static files (CSS, JavaScript, Images)")
print("# https://docs.djangoproject.com/en/stable/howto/static-files/")

print("STATIC_URL = '/static/'")
print("STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') # Directory where static files are collected")

print("# Configure WhiteNoise to serve static files")
print("STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'")

print("# Where Django looks for additional static files (e.g., in app's static directories)")
print("STATICFILES_DIRS = [")
print("    os.path.join(BASE_DIR, 'static'),")
print("]")

print("# Media files (User uploads) - Requires separate configuration, often cloud storage like S3")
print("MEDIA_URL = '/media/'")
print("MEDIA_ROOT = os.path.join(BASE_DIR, 'media')")
print("# For production, consider using cloud storage like AWS S3 or Google Cloud Storage")

print("# Logging configuration (Important for production)")
print("# Configure logging to output errors and important information")
print("# Example basic logging:")
print("LOGGING = {")
print("    'version': 1,")
print("    'disable_existing_loggers': False,")
print("    'handlers': {")
print("        'console': {")
print("            'class': 'logging.StreamHandler',")
print("        },")
print("    },")
print("    'root': {")
print("        'handlers': ['console'],")
print("        'level': 'INFO',")
print("    },")
print("}")

print("# Ensure API keys and secrets are loaded from environment variables")
print("# GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID')")
print("# GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET')")
print("# GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')")
print("# Ensure these are set securely in the production environment")


print("```")
print("\n## 4. Set up Web Server and WSGI Server (Conceptual):")
print("In production, you don't use Django's development server (`runserver`). You need a dedicated web server and a WSGI (Web Server Gateway Interface) server.")

print("\n### Conceptual Setup:")
print("1.  **Install a WSGI server:** Gunicorn is a popular choice for Python.")
print("    *(Already included in the conceptual pip install in the previous step)*")
print("2.  **Create a `Procfile` (for Heroku):** This file tells Heroku how to run your application.")
print("    ```")
print("    # Procfile")
print("    web: gunicorn your_project.wsgi --log-file -")
print("    ```")
print("    *(Replace `your_project` with your actual Django project name)*")
print("    - `web`: Specifies a web process.")
print("    - `gunicorn your_project.wsgi`: Runs the Gunicorn server, pointing to your project's WSGI module.")
print("    - `--log-file -`: Directs logs to standard output, which Heroku captures.")
print("3.  **Configure WSGI File:** Ensure your `your_project/wsgi.py` file is correctly configured to serve your application.")
print("    - It typically imports `get_wsgi_application` and sets the `DJANGO_SETTINGS_MODULE` environment variable.")
print("    - For production, you might need to explicitly set `DJANGO_SETTINGS_MODULE` to your production settings file if you use a different one, though often you just use environment variables to control settings within the main `settings.py`.")
print("    ```python")
print("    # your_project/wsgi.py")
print("    import os")
print("    from django.core.wsgi import get_wsgi_application")

print("    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'your_project.settings') # Points to your settings file")

print("    application = get_wsgi_application()")

print("    # Optional: Wrap with WhiteNoise for static files (if not using a separate static file server)")
print("    # from whitenoise.django import DjangoWhiteNoise")
print("    # application = DjangoWhiteNoise(application)")
print("    ```")
print("4.  **Use WhiteNoise for Static Files (Simple Approach):** For simpler deployments like on Heroku, WhiteNoise is a good option to serve static files directly from Django.")
print("    - Install `whitenoise`.")
print("      *(Already included in the conceptual pip install)*")
print("    - Configure `STATICFILES_STORAGE` in `settings.py` (as shown above).")
print("    - Add `whitenoise.middleware.WhiteNoiseMiddleware` to your `MIDDLEWARE` in `settings.py` (usually near the top, after `SecurityMiddleware`).")
print("    ```python")
print("    # settings.py")
print("    MIDDLEWARE = [")
print("        # ... other middleware")
print("        'django.middleware.security.SecurityMiddleware',")
print("        'whitenoise.middleware.WhiteNoiseMiddleware', # Add this line")
print("        # ... other middleware")
print("    ]")
print("    ```")


print("\nConceptual steps for configuring production settings and setting up the web server have been outlined.")
print("Next, I will describe setting up static file serving and deploying the code.")

"""**Reasoning**:
The current subtask is to deploy the website to a web server. This involves several steps from choosing a platform to testing the deployed application. Since I cannot perform actual deployment steps in this environment, I will outline the conceptual steps and considerations for deployment, covering the instructions sequentially. I will start by describing the platform selection and database setup, as these are foundational steps.
"""

# Step 1: Choose platform and Step 2: Set up database server (Conceptual)

print("--- Conceptual Deployment: Platform Selection and Database Setup ---")

print("\n## 1. Platform Selection Considerations:")
print("Choosing a deployment platform depends on various factors:")
print("- **Cost:** Free tiers vs. paid plans, scaling costs.")
print("- **Ease of Use:** Simplicity of setup, deployment process, dashboard.")
print("- **Scalability:** Ability to handle increased traffic and data over time.")
print("- **Integration:** How well it integrates with databases, storage, and other services.")
print("- **Framework Support:** Good support for Python/Django applications.")
print("\nCommon platforms suitable for Django applications include:")
print("- **Heroku:** Known for ease of use ('git push heroku main'). Offers a free tier (with limitations), managed PostgreSQL database.")
print("- **AWS Elastic Beanstalk:** More powerful and flexible, integrates deeply with other AWS services. Requires more configuration.")
print("- **Google Cloud Platform (GCP) App Engine or Cloud Run:** Serverless or managed options, integrates with GCP services like Cloud SQL (PostgreSQL/MySQL).")
print("- **PythonAnywhere:** Simple hosting specifically for Python web apps, good for smaller projects or beginners.")

print("\nFor this conceptual deployment, let's consider **Heroku** as a straightforward option, although the principles apply to others.")

print("\n## 2. Database Server Setup (Conceptual):")
print("Regardless of the platform, you'll need a production-ready database.")
print("For Django, PostgreSQL is a common and robust choice.")

print("\n### Conceptual Steps for Database Setup (using Heroku PostgreSQL as an example):")
print("1.  **Provision a Database:** On Heroku, you would add the Heroku Postgres add-on to your application.")
print("    ```bash")
print("    heroku addons:create heroku-postgresql:hobby-dev -a your-heroku-app-name")
print("    ```")
print("    *(This is a conceptual command line example)*")
print("2.  **Obtain Database Credentials:** The platform provides the database URL (including hostname, database name, user, password, port). On Heroku, this is typically available in a `DATABASE_URL` environment variable.")
print("3.  **Configure Django Database Settings:** In your Django `settings.py`, you'll need to configure the `DATABASES` setting to use the production database URL.")
print("    - Install a library like `dj-database-url` to easily parse the `DATABASE_URL` environment variable.")
print("      ```bash")
print("      pip install dj-database-url gunicorn psycopg2-binary whitenoise")
print("      ```")
print("      *(Conceptual installation)*")
print("    - In `settings.py`, use `dj_database_url.config()`:")
print("      ```python")
print("      # settings.py")
print("      import dj_database_url")
print("      import os")

print("      # Use the DATABASE_URL environment variable provided by the platform")
print("      DATABASES = {")
print("          'default': dj_database_url.config(conn_max_age=600)")
print("      }")
print("      # Ensure DATABASE_URL is set in your production environment variables")
print("      # e.g., heroku config:set DATABASE_URL='postgres://user:password@host:port/dbname'")
print("      # Or if using .env for local testing of prod settings:")
print("      # load_dotenv()")
print("      # DATABASES['default'] = dj_database_url.config(default=os.environ.get('DATABASE_URL'))")
print("      ```")
print("4.  **Ensure Psycopg2 is Installed:** Django needs a database adapter. For PostgreSQL, `psycopg2-binary` is commonly used.")
print("    *(Already included in the conceptual pip install above)*")


print("\nConceptual steps for platform selection and database setup have been outlined.")
print("Next, I will describe configuring production settings and setting up the web server.")

"""**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.

**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.

**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.

**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.

**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.

**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.
"""

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from django.contrib.auth import get_user_model # Added import
from unittest.mock import patch # Added import
# from .forms import DocumentInputForm # If you use Django Forms
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

class DataInputTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
        self.input_url = reverse('input_form')
        self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission

    def test_input_form_renders_correctly(self):
        self.client.login(username='testuser', password='password123')
        response = self.client.get(self.input_url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'input_form.html')

    # Need to mock the Gemini AI API call for this test
    @patch('your_app.views.model.generate_content') # Adjust the patch path
    def test_successful_data_submission(self, mock_generate_content):
        # Configure the mock Gemini response
        mock_generate_content.return_value.text = "Simulated generated document content."

        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'User entered CP text.',
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran', 'Modul Ajar']
        }
        response = self.client.post(self.generate_url, data)

        self.assertEqual(response.status_code, 302) # Should redirect on success
        self.assertRedirects(response, reverse('document_list')) # Redirects to document list
        # Verify that Document objects were created (requires checking database)
        # from your_app.models import Document # Import your model - Already imported above
        self.assertEqual(Document.objects.count(), 2) # Assuming 2 docs were selected

    def test_submission_with_missing_required_fields(self):
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': '', # Missing CP text
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(response.status_code, 400) # Or check for form errors in response context

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_gemini_api_called_with_correct_prompt(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content"
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Sample CP.',
            'subject': 'Physics',
            'grade_phase': 'Fase E',
            'academic_year': '2024-2025',
            'document_types': ['Alur Tujuan Pembelajaran']
        }
        self.client.post(self.generate_url, data)

        # Assert that generate_content was called
        mock_generate_content.assert_called_once()
        # Inspect the arguments the mock was called with to check the prompt content
        called_prompt = mock_generate_content.call_args[0][0]
        self.assertIn("Sample CP.", called_prompt)
        self.assertIn("Mata Pelajaran: Physics", called_prompt)
        self.assertIn("Instruksi spesifik untuk Alur Tujuan Pembelajaran:", called_prompt)

    @patch('your_app.views.model.generate_content', side_effect=Exception("API Error"))
    def test_gemini_api_error_handling(self, mock_generate_content):
         self.client.login(username='testuser', password='password123')
         data = { # Minimal valid data
            'cp_text': 'Sample CP.', 'subject': 'A', 'grade_phase': 'B',
            'academic_year': 'C', 'document_types': ['Tujuan Pembelajaran']
         }
         response = self.client.post(self.generate_url, data)
         # Check that the response indicates an error (e.g., 500 status, or error message in response)
         self.assertEqual(response.status_code, 500) # Assuming your view returns 500 on API error
         self.assertIn("AI model not configured conceptually", response.content.decode()) # Check for conceptual error message

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_document_saved_to_database(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content."
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Save this CP.',
            'subject': 'History',
            'grade_phase': 'Fase F',
            'academic_year': '2023-2024',
            'document_types': ['Program Tahunan']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(Document.objects.count(), 1)
        doc = Document.objects.first()
        self.assertEqual(doc.user, self.user)
        self.assertEqual(doc.document_type, 'Program Tahunan')
        self.assertEqual(doc.generated_content, 'Simulated content.')
        self.assertEqual(doc.input_data['cp_text'], 'Save this CP.') # Check stored input data

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup
# from your_app.models import Document # Import your model - Already imported above

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    def test_document_list_displays_users_documents(self):
        self.client.login(username='testuser', password='password123')
        # Create some documents for the user
        doc1 = Document.objects.create(user=self.user, document_type='TP', generated_content='TP Content')
        doc2 = Document.objects.create(user=self.user, document_type='ATP', generated_content='ATP Content')
        # Create a document for another user
        other_user = UserModel.objects.create_user(email='other@gmail.com', username='other')
        other_doc = Document.objects.create(user=other_user, document_type='PROSEM', generated_content='Other Content')

        response = self.client.get(reverse('document_list')) # Assuming 'document_list' URL
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_list.html')
        # Check that the user's documents are in the context
        self.assertIn('documents', response.context)
        self.assertEqual(len(response.context['documents']), 2) # Only 2 documents for this user
        self.assertIn(doc1, response.context['documents'])
        self.assertIn(doc2, response.context['documents'])
        self.assertNotIn(other_doc, response.context['documents']) # Other user's document is not listed

    def test_viewing_single_document(self):
        self.client.login(username='testuser', password='password123')
        doc = Document.objects.create(user=self.user, document_type='Modul', generated_content='<h1>Modul Content</h1>')
        response = self.client.get(reverse('view_document', args=[doc.id])) # Assuming 'view_document' URL

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_detail.html')
        self.assertIn('document', response.context)
        self.assertEqual(response.context['document'], doc)
        self.assertContains(response, '<h1>Modul Content</h1>') # Check content is displayed

    def test_accessing_another_users_document_is_forbidden(self):
        self.client.login(username='testuser', password='password123')
        other_user = UserModel.objects.create_user(email='other2@gmail.com', username='other2')
        other_doc = Document.objects.create(user=other_user, document_type='PROTA', generated_content='Other PROTA Content')

        response = self.client.get(reverse('view_document', args=[other_doc.id]))
        # Depending on implementation, this should be 404 or 403
        self.assertIn(response.status_code, [403, 404])

# In tests.py (Conceptual)
from django.test import TestCase # Added import
from django.urls import reverse # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup
# from your_app.models import Document # Import your model - Already imported above

class DataInputTests(TestCase): # Added class definition for context
    # Assuming setUp method is defined in this class or inherited
    # def setUp(self):
    #     self.client = Client()
    #     self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
    #     self.input_url = reverse('input_form')
    #     self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission


    def test_document_list_displays_users_documents(self):
        self.client.login(username='testuser', password='password123')
        # Create some documents for the user
        doc1 = Document.objects.create(user=self.user, document_type='TP', generated_content='TP Content')
        doc2 = Document.objects.create(user=self.user, document_type='ATP', generated_content='ATP Content')
        # Create a document for another user
        other_user = UserModel.objects.create_user(email='other@gmail.com', username='other')
        other_doc = Document.objects.create(user=other_user, document_type='PROSEM', generated_content='Other Content')

        response = self.client.get(reverse('document_list')) # Assuming 'document_list' URL
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_list.html')
        # Check that the user's documents are in the context
        self.assertIn('documents', response.context)
        self.assertEqual(len(response.context['documents']), 2) # Only 2 documents for this user
        self.assertIn(doc1, response.context['documents'])
        self.assertIn(doc2, response.context['documents'])
        self.assertNotIn(other_doc, response.context['documents']) # Other user's document is not listed

    def test_viewing_single_document(self):
        self.client.login(username='testuser', password='password123')
        doc = Document.objects.create(user=self.user, document_type='Modul', generated_content='<h1>Modul Content</h1>')
        response = self.client.get(reverse('view_document', args=[doc.id])) # Assuming 'view_document' URL

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_detail.html')
        self.assertIn('document', response.context)
        self.assertEqual(response.context['document'], doc)
        self.assertContains(response, '<h1>Modul Content</h1>') # Check content is displayed

    def test_accessing_another_users_document_is_forbidden(self):
        self.client.login(username='testuser', password='password123')
        other_user = UserModel.objects.create_user(email='other2@gmail.com', username='other2')
        other_doc = Document.objects.create(user=other_user, document_type='PROTA', generated_content='Other PROTA Content')

        response = self.client.get(reverse('view_document', args=[other_doc.id]))
        # Depending on implementation, this should be 404 or 403
        self.assertIn(response.status_code, [403, 404])

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from django.contrib.auth import get_user_model # Added import
from unittest.mock import patch # Added import
# from .forms import DocumentInputForm # If you use Django Forms
from your_app.models import Document # Import your model - Added import

UserModel = get_user_model() # Added initialization

class DataInputTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
        self.input_url = reverse('input_form')
        self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission

    def test_input_form_renders_correctly(self):
        self.client.login(username='testuser', password='password123')
        response = self.client.get(self.input_url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'input_form.html')

    # Need to mock the Gemini AI API call for this test
    @patch('your_app.views.model.generate_content') # Adjust the patch path
    def test_successful_data_submission(self, mock_generate_content):
        # Configure the mock Gemini response
        mock_generate_content.return_value.text = "Simulated generated document content."

        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'User entered CP text.',
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran', 'Modul Ajar']
        }
        response = self.client.post(self.generate_url, data)

        self.assertEqual(response.status_code, 302) # Should redirect on success
        self.assertRedirects(response, reverse('document_list')) # Redirects to document list
        # Verify that Document objects were created (requires checking database)
        # from your_app.models import Document # Import your model - Already imported above
        self.assertEqual(Document.objects.count(), 2) # Assuming 2 docs were selected

    def test_submission_with_missing_required_fields(self):
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': '', # Missing CP text
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(response.status_code, 400) # Or check for form errors in response context

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_gemini_api_called_with_correct_prompt(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content"
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Sample CP.',
            'subject': 'Physics',
            'grade_phase': 'Fase E',
            'academic_year': '2024-2025',
            'document_types': ['Alur Tujuan Pembelajaran']
        }
        self.client.post(self.generate_url, data)

        # Assert that generate_content was called
        mock_generate_content.assert_called_once()
        # Inspect the arguments the mock was called with to check the prompt content
        called_prompt = mock_generate_content.call_args[0][0]
        self.assertIn("Sample CP.", called_prompt)
        self.assertIn("Mata Pelajaran: Physics", called_prompt)
        self.assertIn("Instruksi spesifik untuk Alur Tujuan Pembelajaran:", called_prompt)

    @patch('your_app.views.model.generate_content', side_effect=Exception("API Error"))
    def test_gemini_api_error_handling(self, mock_generate_content):
         self.client.login(username='testuser', password='password123')
         data = { # Minimal valid data
            'cp_text': 'Sample CP.', 'subject': 'A', 'grade_phase': 'B',
            'academic_year': 'C', 'document_types': ['Tujuan Pembelajaran']
         }
         response = self.client.post(self.generate_url, data)
         # Check that the response indicates an error (e.g., 500 status, or error message in response)
         self.assertEqual(response.status_code, 500) # Assuming your view returns 500 on API error
         self.assertIn("AI model not configured conceptually", response.content.decode()) # Check for conceptual error message

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from unittest.mock import patch # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup

    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_document_saved_to_database(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content."
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Save this CP.',
            'subject': 'History',
            'grade_phase': 'Fase F',
            'academic_year': '2023-2024',
            'document_types': ['Program Tahunan']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(Document.objects.count(), 1)
        doc = Document.objects.first()
        self.assertEqual(doc.user, self.user)
        self.assertEqual(doc.document_type, 'Program Tahunan')
        self.assertEqual(doc.generated_content, 'Simulated content.')
        self.assertEqual(doc.input_data['cp_text'], 'Save this CP.') # Check stored input data

# In tests.py (Conceptual)
from django.test import TestCase, Client # Added import
from django.urls import reverse # Added import
from django.contrib.auth import get_user_model # Added import
from your_app.models import Document # Import your model # Added import

UserModel = get_user_model() # Added initialization

# Continue from DataInputTests setUp or similar setup
# from your_app.models import Document # Import your model - Already imported above

    def test_document_list_displays_users_documents(self):
        self.client.login(username='testuser', password='password123')
        # Create some documents for the user
        doc1 = Document.objects.create(user=self.user, document_type='TP', generated_content='TP Content')
        doc2 = Document.objects.create(user=self.user, document_type='ATP', generated_content='ATP Content')
        # Create a document for another user
        other_user = UserModel.objects.create_user(email='other@gmail.com', username='other')
        other_doc = Document.objects.create(user=other_user, document_type='PROSEM', generated_content='Other Content')

        response = self.client.get(reverse('document_list')) # Assuming 'document_list' URL
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_list.html')
        # Check that the user's documents are in the context
        self.assertIn('documents', response.context)
        self.assertEqual(len(response.context['documents']), 2) # Only 2 documents for this user
        self.assertIn(doc1, response.context['documents'])
        self.assertIn(doc2, response.context['documents'])
        self.assertNotIn(other_doc, response.context['documents']) # Other user's document is not listed

    def test_viewing_single_document(self):
        self.client.login(username='testuser', password='password123')
        doc = Document.objects.create(user=self.user, document_type='Modul', generated_content='<h1>Modul Content</h1>')
        response = self.client.get(reverse('view_document', args=[doc.id])) # Assuming 'view_document' URL

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_detail.html')
        self.assertIn('document', response.context)
        self.assertEqual(response.context['document'], doc)
        self.assertContains(response, '<h1>Modul Content</h1>') # Check content is displayed

    def test_accessing_another_users_document_is_forbidden(self):
        self.client.login(username='testuser', password='password123')
        other_user = UserModel.objects.create_user(email='other2@gmail.com', username='other2')
        other_doc = Document.objects.create(user=other_user, document_type='PROTA', generated_content='Other PROTA Content')

        response = self.client.get(reverse('view_document', args=[other_doc.id]))
        # Depending on implementation, this should be 404 or 403
        self.assertIn(response.status_code, [403, 404])

"""**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.
"""

# Step 3: Explain how to perform these tests in a real Django development environment

print("--- How to Perform These Tests in a Real Django Environment ---")

print("\nTesting a web application involves a combination of automated and manual testing.")

print("\n## 1. Automated Testing (Using Django Test Client)")
print("Django's built-in `django.test.Client` and `TestCase` class are excellent for testing backend logic, views, and forms without needing a browser.")

print("### Setup:")
print("- Create a `tests.py` file in your Django app.")
print("- Import `TestCase` from `django.test` and `reverse` from `django.urls`.")
print("- Import your views, models, and forms.")
print("- You'll need to mock external services like the Google Auth process and the Gemini AI API for reliable automated tests.")

print("\nAutomated tests are typically run using the Django test runner:")
print("```bash")
print("python manage.py test your_app_name")
print("```")
print("*(Replace `your_app_name` with your actual Django app name)*")

print("\n## 2. Manual Testing (Via Browser)")
print("Manual testing involves interacting with your deployed application through a web browser, just like a user would.")

print("\n### Steps for Manual Testing:")
print("- **Run your Django development server:** In your terminal, navigate to your project's root directory and run `python manage.py runserver`.")
print("- **Access the application:** Open a web browser and go to `http://localhost:8000/` (or the address shown in your terminal).")
print("- **Follow the Test Plan:** Go through each test case outlined in the conceptual test plan (Login, Data Input, Document Generation, Document Display, etc.).")
print("- **Verify Expected Outcomes:** For each test case, check if the application behaves as described in the 'Expected Outcome' section of the test plan.")
print("- **Check Browser Developer Tools:** Use your browser's developer tools (usually accessed by pressing F12) to inspect network requests, console logs, and element rendering if issues arise.")
print("- **Test on Different Devices/Browsers:** Ensure compatibility across various platforms.")
print("- **Check Server Logs:** Monitor the output in your terminal where `runserver` is running for any errors or warnings.")

print("\nAutomated testing provides speed and reliability for core logic, while manual testing ensures the full user experience and front-end functionality work correctly.")

print("\nConceptual steps for performing tests in a real Django environment have been outlined.")

# In tests.py (Conceptual)
# from .forms import DocumentInputForm # If you use Django Forms

class DataInputTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = UserModel.objects.create_user(email='testuser@gmail.com', username='testuser', password='password123')
        self.input_url = reverse('input_form')
        self.generate_url = reverse('generate_documents') # Assuming 'generate_documents' is the URL for the view handling submission

    def test_input_form_renders_correctly(self):
        self.client.login(username='testuser', password='password123')
        response = self.client.get(self.input_url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'input_form.html')

    # Need to mock the Gemini AI API call for this test
    @patch('your_app.views.model.generate_content') # Adjust the patch path
    def test_successful_data_submission(self, mock_generate_content):
        # Configure the mock Gemini response
        mock_generate_content.return_value.text = "Simulated generated document content."

        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'User entered CP text.',
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran', 'Modul Ajar']
        }
        response = self.client.post(self.generate_url, data)

        self.assertEqual(response.status_code, 302) # Should redirect on success
        self.assertRedirects(response, reverse('document_list')) # Redirects to document list
        # Verify that Document objects were created (requires checking database)
        from your_app.models import Document # Import your model
        self.assertEqual(Document.objects.count(), 2) # Assuming 2 docs were selected

    def test_submission_with_missing_required_fields(self):
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': '', # Missing CP text
            'subject': 'Math',
            'grade_phase': 'Fase D',
            'academic_year': '2024-2025',
            'document_types': ['Tujuan Pembelajaran']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(response.status_code, 400) # Or check for form errors in response context

# In tests.py (Conceptual)
# Continue from DataInputTests setUp or similar setup

    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_gemini_api_called_with_correct_prompt(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content"
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Sample CP.',
            'subject': 'Physics',
            'grade_phase': 'Fase E',
            'academic_year': '2024-2025',
            'document_types': ['Alur Tujuan Pembelajaran']
        }
        self.client.post(self.generate_url, data)

        # Assert that generate_content was called
        mock_generate_content.assert_called_once()
        # Inspect the arguments the mock was called with to check the prompt content
        called_prompt = mock_generate_content.call_args[0][0]
        self.assertIn("Sample CP.", called_prompt)
        self.assertIn("Mata Pelajaran: Physics", called_prompt)
        self.assertIn("Instruksi spesifik untuk Alur Tujuan Pembelajaran:", called_prompt)

    @patch('your_app.views.model.generate_content', side_effect=Exception("API Error"))
    def test_gemini_api_error_handling(self, mock_generate_content):
         self.client.login(username='testuser', password='password123')
         data = { # Minimal valid data
            'cp_text': 'Sample CP.', 'subject': 'A', 'grade_phase': 'B',
            'academic_year': 'C', 'document_types': ['Tujuan Pembelajaran']
         }
         response = self.client.post(self.generate_url, data)
         # Check that the response indicates an error (e.g., 500 status, or error message in response)
         self.assertEqual(response.status_code, 500) # Assuming your view returns 500 on API error
         self.assertIn("AI model not configured conceptually", response.content.decode()) # Check for conceptual error message

# In tests.py (Conceptual)
# Continue from DataInputTests setUp or similar setup
from your_app.models import Document # Import your model

    @patch('your_app.views.model.generate_content') # Patch the AI call
    def test_document_saved_to_database(self, mock_generate_content):
        mock_generate_content.return_value.text = "Simulated content."
        self.client.login(username='testuser', password='password123')
        data = {
            'cp_text': 'Save this CP.',
            'subject': 'History',
            'grade_phase': 'Fase F',
            'academic_year': '2023-2024',
            'document_types': ['Program Tahunan']
        }
        response = self.client.post(self.generate_url, data)
        self.assertEqual(Document.objects.count(), 1)
        doc = Document.objects.first()
        self.assertEqual(doc.user, self.user)
        self.assertEqual(doc.document_type, 'Program Tahunan')
        self.assertEqual(doc.generated_content, 'Simulated content.')
        self.assertEqual(doc.input_data['cp_text'], 'Save this CP.') # Check stored input data

# In tests.py (Conceptual)
# Continue from DataInputTests setUp or similar setup
from your_app.models import Document # Import your model

    def test_document_list_displays_users_documents(self):
        self.client.login(username='testuser', password='password123')
        # Create some documents for the user
        doc1 = Document.objects.create(user=self.user, document_type='TP', generated_content='TP Content')
        doc2 = Document.objects.create(user=self.user, document_type='ATP', generated_content='ATP Content')
        # Create a document for another user
        other_user = UserModel.objects.create_user(email='other@gmail.com', username='other')
        other_doc = Document.objects.create(user=other_user, document_type='PROSEM', generated_content='Other Content')

        response = self.client.get(reverse('document_list')) # Assuming 'document_list' URL
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_list.html')
        # Check that the user's documents are in the context
        self.assertIn('documents', response.context)
        self.assertEqual(len(response.context['documents']), 2) # Only 2 documents for this user
        self.assertIn(doc1, response.context['documents'])
        self.assertIn(doc2, response.context['documents'])
        self.assertNotIn(other_doc, response.context['documents']) # Other user's document is not listed

    def test_viewing_single_document(self):
        self.client.login(username='testuser', password='password123')
        doc = Document.objects.create(user=self.user, document_type='Modul', generated_content='<h1>Modul Content</h1>')
        response = self.client.get(reverse('view_document', args=[doc.id])) # Assuming 'view_document' URL

        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'document_detail.html')
        self.assertIn('document', response.context)
        self.assertEqual(response.context['document'], doc)
        self.assertContains(response, '<h1>Modul Content</h1>') # Check content is displayed

    def test_accessing_another_users_document_is_forbidden(self):
        self.client.login(username='testuser', password='password123')
        other_user = UserModel.objects.create_user(email='other2@gmail.com', username='other2')
        other_doc = Document.objects.create(user=other_user, document_type='PROTA', generated_content='Other PROTA Content')

        response = self.client.get(reverse('view_document', args=[other_doc.id]))
        # Depending on implementation, this should be 404 or 403
        self.assertIn(response.status_code, [403, 404])

"""**Reasoning**:
Outline the conceptual test plan, including test cases for each feature and their expected outcomes.
"""

# Step 1: Write a conceptual test plan
# Step 2: Describe the expected outcome for each test case

print("--- Conceptual Test Plan ---")

print("\n## 1. Login Feature Tests")
print("### Test Cases:")
print("- **Test Case 1.1:** Successful Google Login")
print("  - **Description:** User clicks 'Sign in with Google' and completes the Google authentication flow.")
print("  - **Expected Outcome:** User is successfully authenticated and redirected to the document input page (or `LOGIN_REDIRECT_URL`). A new user or social account is created/linked in the database.")

print("- **Test Case 1.2:** Login with Existing Google Account")
print("  - **Description:** User who previously logged in with Google attempts to log in again.")
print("  - **Expected Outcome:** User is successfully authenticated and redirected. The existing user and social account are used; no new ones are created.")

print("- **Test Case 1.3:** Login Failure (e.g., Google error, user cancels)")
print("  - **Description:** User attempts Google login but the process fails or is cancelled on the Google side.")
print("  - **Expected Outcome:** User is returned to the login page with an appropriate error message (handled by `django-allauth`).")

print("- **Test Case 1.4:** Accessing Protected Page Before Login")
print("  - **Description:** Anonymous user attempts to access a page requiring authentication (e.g., input form, document list) directly via URL.")
print("  - **Expected Outcome:** User is redirected to the login page (`ACCOUNT_LOGOUT_REDIRECT_URL` or similar setting).")


print("\n## 2. Data Input Feature Tests")
print("### Test Cases:")
print("- **Test Case 2.1:** Successful Data Submission")
print("  - **Description:** Logged-in user fills in all required fields on the input form (CP text, subject, grade/phase, academic year) and selects at least one document type, then submits.")
print("  - **Expected Outcome:** The form submission is successful (HTTP 200 or 302 redirect). The backend receives the input data and initiated the document generation process. User is redirected to the document list or a confirmation page.")

print("- **Test Case 2.2:** Missing Required Fields")
print("  - **Description:** Logged-in user attempts to submit the input form with one or more required fields left blank (e.g., empty CP text, no document types selected).")
print("  - **Expected Outcome:** The server returns an error (e.g., HTTP 400) or the form displays validation errors, preventing submission or indicating missing fields.")

print("- **Test Case 2.3:** Invalid Data Format (if applicable, e.g., non-numeric year)")
print("  - **Description:** User enters data in an unexpected format (e.g., text in a field expecting a year, although current fields are flexible).")
print("  - **Expected Outcome:** Depending on backend validation, the server returns an error or validation fails. (Less critical for current text-based fields).")


print("\n## 3. Document Generation Feature Tests")
print("### Test Cases:")
print("- **Test Case 3.1:** Generation of Single Document Type")
print("  - **Description:** User inputs data and selects only one document type (e.g., 'Tujuan Pembelajaran').")
print("  - **Expected Outcome:** The backend successfully calls the Gemini AI API with a prompt specific to 'Tujuan Pembelajaran'. The API returns content, which is processed and conceptually saved.")

print("- **Test Case 3.2:** Generation of Multiple Document Types")
print("  - **Description:** User inputs data and selects multiple document types (e.g., 'Tujuan Pembelajaran', 'Alur Tujuan Pembelajaran').")
print("  - **Expected Outcome:** The backend successfully calls the Gemini AI API for *each* selected document type with appropriate prompts. API returns content for each, which is processed and conceptually saved.")

print("- **Test Case 3.3:** Gemini AI API Error Handling")
print("  - **Description:** The Gemini AI API returns an error during the generation process (e.g., rate limit exceeded, invalid request).")
print("  - **Expected Outcome:** The backend catches the API error. An appropriate error message is displayed to the user or logged, and the process for that document type might fail gracefully.")

print("- **Test Case 3.4:** Content Relevance and Structure (Manual/Qualitative Test)")
print("  - **Description:** Review the generated document content for accuracy, relevance to the input CP, and adherence to the requested structure (e.g., Markdown headings, lists, tables).")
print("  - **Expected Outcome:** The generated content is largely relevant to the input and follows the structural instructions given in the prompt.")


print("\n## 4. Data Storage Feature Tests")
print("### Test Cases:")
print("- **Test Case 4.1:** Document Saved to Database After Generation")
print("  - **Description:** After successful document generation, check the database.")
print("  - **Expected Outcome:** A new record exists in the `Documents` table for each successfully generated document type. Each record is linked to the logged-in user, contains the correct document type, the input data, and the generated content.")

print("- **Test Case 4.2:** Input Data Stored Correctly")
print("  - **Description:** Examine the `input_data` field in the saved document record.")
print("  - **Expected Outcome:** The `input_data` field (e.g., JSON or text) accurately reflects the data submitted by the user (CP text, subject, etc.).")

print("- **Test Case 4.3:** Generated Content Stored Correctly")
print("  - **Description:** Examine the `generated_content` field in the saved document record.")
print("  - **Expected Outcome:** The `generated_content` field contains the exact text received from the Gemini AI API for that document type.")

print("- **Test Case 4.4:** Document Linked to Correct User")
print("  - **Description:** Examine the `user_id` field in the saved document record.")
print("  - **Expected Outcome:** The `user_id` field correctly references the primary key of the logged-in user in the `Users` table.")


print("\n## 5. Document Display Feature Tests")
print("### Test Cases:")
print("- **Test Case 5.1:** List of User's Documents Displayed")
print("  - **Description:** Logged-in user navigates to the document list page.")
print("  - **Expected Outcome:** The page displays a list of all documents previously generated and saved for this user, showing document type and potentially creation date.")

print("- **Test Case 5.2:** Viewing a Specific Document")
print("  - **Description:** User clicks on a document in the list.")
print("  - **Expected Outcome:** The content of the selected document is displayed. The displayed content matches the `generated_content` stored in the database for that document.")

print("- **Test Case 5.3:** Document Content Formatting")
print("  - **Description:** View the displayed document content, especially if it uses Markdown.")
print("  - **Expected Outcome:** The Markdown formatting (headings, lists, tables) is rendered correctly in the web browser.")

print("- **Test Case 5.4:** Accessing Another User's Document (Security Test)")
print("  - **Description:** Attempt to access a document belonging to a different user by manipulating the URL (e.g., changing the document ID).")
print("  - **Expected Outcome:** The server prevents access and returns an error (e.g., HTTP 404 Not Found or HTTP 403 Forbidden), as the document is not owned by the currently logged-in user.")

"""## Pengujian

### Subtask:
Melakukan pengujian menyeluruh untuk memastikan semua fitur berfungsi dengan baik, termasuk login, input data, generasi dokumen, dan penyimpanan.

**Reasoning**:
Describe modifying the `generate_documents_view` to save the document objects to the database after generation. This covers steps 2-5 of the subtask.

**Reasoning**:
Describe modifying the `generate_documents_view` to save the document objects to the database after generation. This covers steps 2-5 of the subtask.
"""

# Step 2-5: Describe modifying the generate_documents_view to save documents and redirect using simpler prints

print("--- Conceptual Modifications to generate_documents_view (Attempt 2) ---")
print("In your Django app's `views.py` file, you need to modify the `generate_documents_view` function.")
print("")
print("After you successfully get the `generated_content` from the Gemini API for each `doc_type`,")
print("you will create a `Document` object and save it.")
print("")
print("Here's the conceptual code snippet to add within the `for doc_type in document_types:` loop,")
print("after `generated_content` is obtained:")
print("")
print("```python")
print("# Assuming 'generated_content' contains the AI-generated text for the current doc_type")
print("")
print("# Create a new Document object")
print("document = Document(")
print("    user=request.user, # The currently logged-in user")
print("    document_type=doc_type,")
print("    input_data={")
print("        'cp_text': cp_text,")
print("        'subject': subject,")
print("        'grade_phase': grade_phase,")
print("        'academic_year': academic_year")
print("        # Add any other relevant input data here that you want to store")
print("    },")
print("    generated_content=generated_content")
print(")")
print("")
print("# Save the document to the database")
print("document.save()")
print("")
print("# Optional: Store document ID if needed later, though redirecting to list is common")
print("# generated_docs_data[doc_type] = document.id # Store the ID if needed")
print("```")
print("")
print("After the loop finishes (meaning all selected documents have been generated and saved),")
print("you should redirect the user to the document list page.")
print("Replace the current return statement with a redirect:")
print("")
print("```python")
print("# After the for loop finishes:")
print("from django.shortcuts import redirect # Make sure to import 'redirect' at the top")
print("")
print("# Assuming a URL named 'document_list' exists in your urls.py")
print("return redirect('document_list')")
print("```")
print("")
print("This modification ensures that each generated document is persistently stored in the database")
print("and the user is directed to a page where they can view their saved documents.")

# After the for loop finishes:
from django.shortcuts import redirect

# Assuming a URL named 'document_list' exists in your urls.py
return redirect('document_list')

# Make sure to import 'redirect' at the top of your views.py

# Step 1: Describe Django models conceptually using simpler prints

print("--- Conceptual Django Model Definitions (Attempt 3) ---")
print("In a real Django project, you would define your models in a file like `your_app/models.py`.")
print("")
print("We will use the built-in Django `User` model, which `django-allauth` integrates with.")
print("We need a `Document` model to store the generated content, linked to the `User`.")
print("")
print("```python")
print("from django.db import models")
print("from django.contrib.auth.models import User")
print("")
print("class Document(models.Model):")
print("    \"\"\"Model to store generated learning documents.\"\"\"")
print("    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='documents')")
print("    document_type = models.CharField(max_length=255)")
print("    input_data = models.JSONField(default=dict)")
print("    generated_content = models.TextField()")
print("    created_at = models.DateTimeField(auto_now_add=True)")
print("    updated_at = models.DateTimeField(auto_now=True)")
print("")
print("    def __str__(self):")
print("        return f\"{self.document_type} for {self.user.email} ({self.created_at.strftime('%Y-%m-%d')})\"")
print("")
print("    class Meta:")
print("        ordering = ['-created_at']")
print("```")
print("")
print("This conceptual code defines the structure needed for the `Document` model.")
print("")
print("--- Conceptual Migration Steps (Attempt 3) ---")
print("Because we cannot execute Django management commands in this environment, we conceptually outline the steps:")
print("")
print("1. Add your app to `INSTALLED_APPS` in `settings.py`.")
print("2. Run `python manage.py makemigrations your_app_name` in your terminal.")
print("3. Run `python manage.py migrate` in your terminal.")
print("")
print("These steps are essential to set up the database schema.")

"""**Reasoning**:
The previous attempt failed because Django settings are not configured in this environment, preventing model definition. Since actual model definition and migration execution are not possible, I will describe the conceptual model definitions again and reiterate the migration steps, acknowledging the environment limitation.
"""

python manage.py makemigrations your_app_name

python manage.py migrate

"""**Reasoning**:
The previous attempt failed because Django settings are not configured in this environment, preventing model definition. Since actual model definition and migration execution are not possible, I will describe the conceptual model definitions again and reiterate the migration steps, acknowledging the environment limitation.
"""

python manage.py makemigrations your_app_name

python manage.py migrate

"""**Reasoning**:
Define the Django models for User and Document, including the necessary fields and relationships, and then conceptually run migrations.
"""

# In your Django app's models.py

from django.db import models
from django.contrib.auth.models import User # Django's built-in User model
from allauth.socialaccount.models import SocialAccount # Import SocialAccount

# Step 1: Define Django models

# We can leverage the built-in Django User model.
# allauth automatically links SocialAccount to the built-in User.
# No need to define a custom User model unless we need extra profile fields
# beyond what SocialAccount provides (e.g., Google ID, email are in SocialAccount).

# Define the Document model
class Document(models.Model):
    """
    Model to store generated learning documents.
    """
    # Link to the User model
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='documents')

    document_type = models.CharField(max_length=255) # e.g., 'Tujuan Pembelajaran', 'Modul Ajar'

    # Store user input data - using JSONField is flexible
    # Requires PostgreSQL or a library like django-jsonfield for other databases
    # Or use a TextField and store data as JSON string
    input_data = models.JSONField(default=dict)

    # Store the generated content from Gemini AI
    generated_content = models.TextField()

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.document_type} for {self.user.email} ({self.created_at.strftime('%Y-%m-%d')})"

    class Meta:
        ordering = ['-created_at'] # Order by most recent first

# Conceptual steps to apply migrations
print("--- Conceptual Django Model Definitions ---")
print("Defined Document model linked to the built-in User model.")
print("--- Conceptual Migration Steps ---")
print("""
In a real Django project, after defining or modifying models, you would run:

python manage.py makemigrations
python manage.py migrate

These commands create database tables based on your model definitions.
""")

"""## Penyimpanan data

### Subtask:
Menyimpan data pengguna dan dokumen yang dihasilkan di basis data terkait dengan akun Google mereka.

**Reasoning**:
The previous command failed because Django settings were not configured in this environment, causing an error when trying to access `settings.GEMINI_API_KEY`. To proceed and demonstrate the conceptual view logic for interacting with the Gemini API, I need to modify the code to handle the absence of Django settings in this environment. I will do this by either configuring the API key within the view function itself using a placeholder or by adding a check to see if settings are configured before attempting to access the API key. This will allow the conceptual code to execute without the Django settings error, focusing on the AI interaction logic.

**Reasoning**:
Refine the prompt generation logic, implement the actual call to the configured Gemini AI model, extract the generated text content, and structure the extracted content within the conceptual `generate_documents_view` function.
"""

# In your Django app's views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.conf import settings # Import settings to access GEMINI_API_KEY
import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# In a real application, you would do this once, perhaps in app's ready() or a utility function
try:
    genai.configure(api_key=settings.GEMINI_API_KEY)
    model = genai.GenerativeModel('gemini-pro')
    print("Gemini AI model configured successfully.")
except Exception as e:
    print(f"Error configuring Gemini AI model: {e}")
    model = None # Set model to None if configuration fails

@login_required
def generate_documents_view(request):
    if request.method == 'POST':
        cp_text = request.POST.get('cp_text', '')
        subject = request.POST.get('subject', '')
        grade_phase = request.POST.get('grade_phase', '')
        academic_year = request.POST.get('academic_year', '')
        document_types = request.POST.getlist('document_types') # Get list of selected types

        if not cp_text or not document_types:
            # Handle missing required input
            return HttpResponse("Missing required input", status=400)

        if not model:
            return HttpResponse("AI model not configured. Please check API key.", status=500)


        generated_docs_data = {}

        for doc_type in document_types:
            # Step 1: Refine the prompt generation logic
            # Create specific and detailed prompts for each document type
            base_prompt = f'''
            Anda adalah seorang ahli kurikulum merdeka yang membantu guru dalam menyusun dokumen pembelajaran.
            Berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan dari pengguna,
            buatlah dokumen {doc_type} dengan struktur yang jelas dan mendalam sesuai dengan kurikulum merdeka.

            Capaian Pembelajaran (CP):
            {cp_text}

            Data Tambahan:
            Mata Pelajaran: {subject}
            Kelas/Fase: {grade_phase}
            Tahun Ajaran: {academic_year}

            Instruksi spesifik untuk {doc_type}:
            '''

            # Add specific instructions based on document type
            if doc_type == 'Benah Capaian Pembelajaran':
                specific_instructions = '''
                Analisis CP di atas. Identifikasi elemen-elemen kunci dan kata kerja operasional.
                Sajikan kembali CP dalam bahasa yang lebih mudah dipahami atau diuraikan jika perlu (Benahan CP).
                Jelaskan implikasi CP ini untuk pembelajaran dan asesmen di kelas/fase ini.
                Format output: Bagian untuk "Capaian Pembelajaran Asli", "Benahan CP", dan "Implikasi Pembelajaran & Asesmen". Gunakan heading Markdown.
                '''
            elif doc_type == 'Tujuan Pembelajaran':
                specific_instructions = '''
                Uraikan CP di atas menjadi beberapa Tujuan Pembelajaran (TP).
                Setiap TP harus spesifik, terukur, dapat dicapai, relevan, dan berbasis waktu (SMART jika memungkinkan, atau setidaknya jelas komponennya).
                Sertakan elemen-elemen TP seperti Kompetensi, Konten, dan Variasi (sesuai kurikulum merdeka).
                Format output: Daftar TP bernomor atau berpoin dengan penjelasan singkat untuk setiap TP. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Alur Tujuan Pembelajaran':
                specific_instructions = '''
                Berdasarkan Tujuan Pembelajaran (TP) yang mungkin diimplikasikan dari CP (atau asumsikan TP yang relevan jika TP belum dibuat),
                susunlah Alur Tujuan Pembelajaran (ATP) yang logis dan berkesinambungan untuk satu fase atau satu tahun ajaran.
                Perkirakan alokasi waktu untuk setiap segmen ATP.
                Format output: Daftar ATP berurutan, jelaskan setiap langkah, dan sertakan perkiraan alokasi waktu. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Kriteria Ketuntasan Tujuan Pembelajaran':
                 specific_instructions = '''
                 Untuk setiap Tujuan Pembelajaran (TP) yang diimplikasikan dari CP, buatlah Kriteria Ketuntasan Tujuan Pembelajaran (KKTP).
                 KKTP harus jelas dan dapat diobservasi, menunjukkan bukti bahwa siswa telah mencapai tujuan pembelajaran.
                 Sertakan contoh bentuk asesmen yang dapat digunakan untuk mengukur KKTP tersebut.
                 Format output: Untuk setiap TP, sajikan KKTP dan contoh bentuk asesmen terkait. Gunakan heading, list, dan tabel sederhana Markdown.
                 '''
            elif doc_type == 'Program Semester':
                 specific_instructions = '''
                 Susunlah Program Semester (PROSEM) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam mingguan selama satu semester.
                 Sertakan topik/materi utama, kegiatan pembelajaran singkat, dan rencana asesmen untuk setiap minggu.
                 Format output: Tabel mingguan yang mencakup Minggu ke-, Topik/ATP, Kegiatan Singkat, dan Asesmen. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Program Tahunan':
                 specific_instructions = '''
                 Susunlah Program Tahunan (PROTA) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam bulanan atau per unit pembelajaran utama selama satu tahun ajaran.
                 Sertakan topik/materi utama dan perkiraan alokasi waktu untuk setiap unit/bulan.
                 Format output: Tabel bulanan/unit yang mencakup Bulan/Unit, Topik/ATP, dan Alokasi Waktu. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Modul Ajar':
                 specific_instructions = '''
                 Buatlah kerangka Modul Ajar lengkap untuk satu atau dua pertemuan berdasarkan Tujuan Pembelajaran (TP) dan Kriteria Ketuntasan Tujuan Pembelajaran (KKTP) yang diimplikasikan dari CP.
                 Sertakan komponen inti modul ajar seperti: Informasi Umum (identitas, kompetensi awal, profil pelajar pancasila, sarana prasarana, target peserta didik, model pembelajaran), Komponen Inti (tujuan pembelajaran, pemahaman bermakna, pertanyaan pemantik, kegiatan pembelajaran - pendahuluan, inti, penutup, asesmen - formatif/sumatif, pengayaan/remidial, refleksi guru/siswa), dan Lampiran (lembar kerja, bahan bacaan, glosarium, daftar pustaka).
                 Fokus pada bagian Komponen Inti dengan detail kegiatan pembelajaran.
                 Format output: Gunakan heading dan sub-heading Markdown untuk setiap bagian modul ajar.
                 '''
            else:
                # Default prompt if document type is not specifically handled
                specific_instructions = f'''
                Buatlah dokumen {doc_type} berdasarkan CP dan data tambahan di atas.
                Pastikan formatnya jelas dan relevan dengan konteks pembelajaran.
                Sajikan output dalam format Markdown.
                '''

            prompt = base_prompt + specific_instructions

            try:
                # Step 2: Implement the actual call to the configured Gemini AI model
                response = model.generate_content(prompt)
                # Step 3: Extract the generated text content from the Gemini API response
                generated_content = response.text # Extract text content

                # Step 4: Structure the extracted content
                # For now, we'll just store the text content.
                # If the prompt specifically asks for JSON or another format,
                # you would add parsing logic here. Markdown text is suitable for direct display.

                # Save the generated document to the database (conceptual)
                # document = Document(
                #     user=request.user,
                #     document_type=doc_type,
                #     input_data={
                #         'cp_text': cp_text,
                #         'subject': subject,
                #         'grade_phase': grade_phase,
                #         'academic_year': academic_year
                #         # Add other relevant input data here
                #     },
                #     generated_content=generated_content
                # )
                # document.save()
                # generated_docs_data[doc_type] = {'id': document.id, 'content': generated_content} # Store ID and content

                # For conceptual purposes, just store the content
                generated_docs_data[doc_type] = generated_content


            except Exception as e:
                # Handle API errors
                print(f"Error generating {doc_type}: {e}")
                generated_docs_data[doc_type] = f"Error generating document: {e}" # Indicate error in output


        # Redirect to a page showing the generated documents or a success message
        # Assuming a URL named 'document_list' exists
        # return redirect('document_list')
        # Or render a page showing the generated_docs_data content

        # For conceptual purposes, render a simple template showing generated content
        # You would need a template like 'generated_output.html'
        # return render(request, 'generated_output.html', {'generated_docs': generated_docs_data})

        # Returning a simple HttpResponse for demonstration
        output_html = "<h2>Generated Documents (Conceptual)</h2>"
        if generated_docs_data:
            for doc_type, content in generated_docs_data.items():
                output_html += f"<h3>{doc_type}</h3>"
                output_html += f"<pre>{content}</pre>" # Use <pre> to preserve formatting
                output_html += "<hr>"
        else:
             output_html += "<p>No documents were generated.</p>"


        return HttpResponse(output_html)


    # If not POST, maybe redirect or show an error
    return redirect('input_form') # Redirect back to the input form

# Step 3-6: Present conceptual Django view logic as a string

conceptual_view_code = """
# In your Django app's views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.conf import settings # Import settings to access GEMINI_API_KEY
import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
def generate_documents_view(request):
    if request.method == 'POST':
        cp_text = request.POST.get('cp_text', '')
        subject = request.POST.get('subject', '')
        grade_phase = request.POST.get('grade_phase', '')
        academic_year = request.POST.get('academic_year', '')
        document_types = request.POST.getlist('document_types') # Get list of selected types

        if not cp_text or not document_types:
            # Handle missing required input
            return HttpResponse("Missing required input", status=400)

        generated_docs = {}

        for doc_type in document_types:
            # Step 4: Prepare the prompt based on user input and document type
            prompt = f'''
            Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

            Capaian Pembelajaran:
            {cp_text}

            Data Tambahan:
            Mata Pelajaran: {subject}
            Kelas/Fase: {grade_phase}
            Tahun Ajaran: {academic_year}

            Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
            '''

            try:
                # Step 5: Send request to Gemini API and handle response
                # Step 6: Extract generated content
                # Replace with actual API call:
                # response = model.generate_content(prompt)
                # generated_content = response.text # Extract text content

                # Simulate API response for conceptual purposes
                simulated_response_content = f"## {doc_type} (Generated)\\n\\nContent based on provided CP and data."
                generated_content = simulated_response_content


                # Save the generated document to the database
                # document = Document(
                #     user=request.user,
                #     document_type=doc_type,
                #     input_data={
                #         'cp_text': cp_text,
                #         'subject': subject,
                #         'grade_phase': grade_phase,
                #         'academic_year': academic_year
                #         # Add other relevant input data here
                #     },
                #     generated_content=generated_content
                # )
                # document.save()
                # generated_docs[doc_type] = document.id # Store the ID for redirection/display

                # For conceptual purposes, just store content
                generated_docs[doc_type] = generated_content


            except Exception as e:
                # Handle API errors
                print(f"Error generating {doc_type}: {e}")
                generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


        # Redirect to a page showing the generated documents or a success message
        # Assuming a URL named 'document_list' exists
        # return redirect('document_list')
        # Or render a page showing the generated_docs dictionary content

        # For conceptual purposes, return a simple HTTP response or render a conceptual template
        return HttpResponse(f"Generated documents: {', '.join(generated_docs.keys())} (Conceptual)")


    # If not POST, maybe redirect or show an error
    return redirect('input_form') # Redirect back to the input form

"""

print("--- Conceptual Django View Code for Gemini API Interaction ---")
print(conceptual_view_code)

print("\nConceptual Django view for interacting with the Gemini API has been presented as a string.")
print("This view handles receiving user input, preparing the prompt, calling the API (conceptually shown), and processing the response.")

"""## Implementasi fitur pembuatan dokumen

### Subtask:
Mengembangkan logika untuk menghasilkan dokumen-dokumen seperti Tujuan Pembelajaran, Alur Tujuan Pembelajaran, KKTP, PROSEM, PROTA, dan Modul Ajar berdasarkan output dari Gemini AI dan data input pengguna.

**Reasoning**:
The syntax error persists, likely due to the commented-out nature of the code block. While it's intended to be conceptual, the interpreter is still parsing it. I will add a simple, executable print statement outside the commented block to ensure the command runs and the conceptual description is still printed.

**Reasoning**:
The previous command failed due to a `SyntaxError`. I need to regenerate the code block containing the conceptual Django view, ensuring correct Python syntax.

**Reasoning**:
Create a Django view function to handle the API interaction with Gemini, including preparing the prompt and processing the response.
"""

# Step 3-6: Create Django view to interact with Gemini API

# In your Django app's views.py

# from django.shortcuts import render, redirect
# from django.http import HttpResponse
# from django.contrib.auth.decorators import login_required
# from django.conf import settings # Import settings to access GEMINI_API_KEY
# import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
# def generate_documents_view(request):
#     if request.method == 'POST':
#         cp_text = request.POST.get('cp_text', '')
#         subject = request.POST.get('subject', '')
#         grade_phase = request.POST.get('grade_phase', '')
#         academic_year = request.POST.get('academic_year', '')
#         document_types = request.POST.getlist('document_types') # Get list of selected types

#         if not cp_text or not document_types:
#             # Handle missing required input
#             return HttpResponse("Missing required input", status=400)

#         generated_docs = {}

#         for doc_type in document_types:
#             # Step 4: Prepare the prompt based on user input and document type
#             prompt = f"""
#             Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

#             Capaian Pembelajaran:
#             {cp_text}

#             Data Tambahan:
#             Mata Pelajaran: {subject}
#             Kelas/Fase: {grade_phase}
#             Tahun Ajaran: {academic_year}

#             Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
#             """

#             try:
#                 # Step 5: Send request to Gemini API and handle response
#                 # Step 6: Extract generated content
#                 response = model.generate_content(prompt)
#                 generated_content = response.text # Extract text content

#                 # Save the generated document to the database
#                 # document = Document(
#                 #     user=request.user,
#                 #     document_type=doc_type,
#                 #     input_data={
#                 #         'cp_text': cp_text,
#                 #         'subject': subject,
#                 #         'grade_phase': grade_phase,
#                 #         'academic_year': academic_year
#                 #         # Add other relevant input data here
#                 #     },
#                 #     generated_content=generated_content
#                 # )
#                 # document.save()
#                 # generated_docs[doc_type] = document.id # Store the ID for redirection/display

#                 # For conceptual purposes, just store content in a dictionary
#                 generated_docs[doc_type] = generated_content


#             except Exception as e:
#                 # Handle API errors
#                 print(f"Error generating {doc_type}: {e}")
#                 generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


#         # Redirect to a page showing the generated documents or a success message
#         # return redirect('document_list') # Redirect to the document list page
#         # Or render a success page showing generated content directly

#         # For conceptual purposes, print the generated content
#         print("\n--- Generated Documents (Conceptual) ---")
#         for doc_type, content in generated_docs.items():
#             print(f"\n### {doc_type}\n")
#             print(content)
#             print("-" * 20)


#     # If not POST, maybe redirect or show an error
#     # return redirect('input_form') # Redirect back to the input form
#     pass # Conceptual - no actual processing here

print("Conceptual Django view for interacting with the Gemini API has been created.")
print("This view handles receiving user input, preparing the prompt, calling the API, and conceptually processing the response.")

"""**Reasoning**:
Describe how to obtain the Gemini API key and how to store it securely in the Django project settings.
"""

import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')

        # You can add a check to ensure the key is loaded
        # if not GEMINI_API_KEY:
        #     raise EnvironmentError("GEMINI_API_KEY not found in environment variables.")

"""**Reasoning**:
Describe how to obtain the Gemini API key and how to store it securely in the Django project settings.
"""

# Step 2: Describe obtaining the Gemini API key and secure storage

print("--- Conceptual Steps for Obtaining Gemini API Key ---")
print("""
1.  Go to Google AI Studio (https://aistudio.google.com/).
2.  Create or select a project.
3.  In the left navigation, find "Get API key".
4.  Click "Create API key in new project" or "Create API key" in an existing project.
5.  Copy the generated API key.
""")

print("\n--- Conceptual Steps for Securely Storing Gemini API Key in Django ---")
print("""
Similar to the Google OAuth credentials, the Gemini API key should be stored securely and not hardcoded directly in `settings.py`.

1.  **Using environment variables (Recommended):**
    *   Ensure you have `python-dotenv` installed (`pip install python-dotenv`).
    *   Add the API key to your `.env` file (which should be in `.gitignore`):

import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')

        # You can add a check to ensure the key is loaded
        # if not GEMINI_API_KEY:
        #     raise EnvironmentError("GEMINI_API_KEY not found in environment variables.")

"""**Reasoning**:
Install the Google Generative AI SDK to interact with the Gemini API.
"""

import subprocess
import sys

try:
    subprocess.run([sys.executable, "-m", "pip", "install", "google-generativeai"], check=True)
    print("Successfully installed google-generativeai")
except subprocess.CalledProcessError as e:
    print(f"Error installing google-generativeai: {e}")
except FileNotFoundError:
    print("Error: 'pip' or 'python' command not found.")

"""## Integrasi gemini ai

### Subtask:
Mengintegrasikan Gemini AI untuk menghasilkan dokumen berdasarkan input pengguna. Ini akan melibatkan pemanggilan API Gemini dengan prompt yang sesuai.

**Reasoning**:
Create the necessary Django views to render the input form and display generated documents, including retrieving documents for the logged-in user.
"""

# This is a conceptual representation of Django views.
# In a real Django project, you would create these functions in your 'views.py' file.

from django.shortcuts import render
from django.contrib.auth.decorators import login_required
# Assuming you have a Document model in your models.py
# from .models import Document

# Step 3: View to handle the rendering of the input form template.
@login_required # Ensures the user is logged in
def input_form_view(request):
    """Renders the form for inputting Capaian Pembelajaran and additional data."""
    return render(request, 'input_form.html')

# Step 4: View to handle the display of generated documents.
@login_required # Ensures the user is logged in
def document_list_view(request):
    """Retrieves and displays the list of documents generated by the logged-in user."""
    # In a real application, you would query the database:
    # user_documents = Document.objects.filter(user=request.user).order_by('-created_at')

    # For conceptual purposes, simulate retrieving documents
    # You would replace this with actual database interaction
    user_documents = [
        {'id': 1, 'document_type': 'Tujuan Pembelajaran', 'created_at': '2023-10-27'},
        {'id': 2, 'document_type': 'Alur Tujuan Pembelajaran', 'created_at': '2023-10-26'},
        {'id': 3, 'document_type': 'Modul Ajar', 'created_at': '2023-10-25'},
    ]


    return render(request, 'document_list.html', {'documents': user_documents})

# Optional: View to display a single document's content (if not using AJAX)
@login_required
def view_document_detail(request, document_id):
    """Retrieves and displays the content of a single document."""
    # In a real application, you would retrieve the document by ID and user:
    # try:
    #     document = Document.objects.get(id=document_id, user=request.user)
    # except Document.DoesNotExist:
    #     # Handle case where document doesn't exist or doesn't belong to user
    #     return render(request, 'document_not_found.html', status=404)

    # For conceptual purposes, simulate retrieving document content
    # Replace with actual database interaction
    simulated_documents = {
        1: {'document_type': 'Tujuan Pembelajaran', 'created_at': '2023-10-27', 'generated_content': '<p>Example TP content...</p>'},
        2: {'document_type': 'Alur Tujuan Pembelajaran', 'created_at': '2023-10-26', 'generated_content': '<p>Example ATP content...</p>'},
        3: {'document_type': 'Modul Ajar', 'created_at': '2023-10-25', 'generated_content': '<p>Example Modul Ajar content...</p>'},
    }
    document = simulated_documents.get(document_id)

    if document:
         return render(request, 'document_detail.html', {'document': document})
    else:
         # Handle case where document is not found in simulation
         return render(request, 'document_not_found.html', status=404)


print("Conceptual Django views for input form and document display have been created.")

"""**Reasoning**:
Create the necessary Django templates as HTML files for the input form and document display.
"""

# This is a conceptual representation of creating HTML template files.
# In a real Django project, you would create these files in your 'templates' directory.

# Conceptual input form template (templates/input_form.html)
print("--- Conceptual input_form.html Template ---")
print("""
{% extends 'base.html' %} {# Assuming a base template exists #}
{% load socialaccount %} {# Load socialaccount tags if needed for user info #}

{% block title %}Input Data & Generate Documents{% endblock %}

{% block content %}
    <h2>Generate Learning Documents</h2>

    {% if user.is_authenticated %}
        <p>Logged in as: {{ user.email }}</p>

        <form method="post" action="{% url 'generate_documents' %}">
            {% csrf_token %}

            <h3>Capaian Pembelajaran (CP)</h3>
            <div class="form-group">
                <label for="cp_text">Teks Capaian Pembelajaran:</label>
                <textarea id="cp_text" name="cp_text" rows="10" class="form-control" required></textarea>
            </div>

            <h3>Data Tambahan</h3>
            <div class="form-group">
                <label for="subject">Mata Pelajaran:</label>
                <input type="text" id="subject" name="subject" class="form-control" required>
            </div>

            <div class="form-group">
                <label for="grade_phase">Kelas/Fase:</label>
                <input type="text" id="grade_phase" name="grade_phase" class="form-control" required>
            </div>

            <div class="form-group">
                <label for="academic_year">Tahun Ajaran:</label>
                <input type="text" id="academic_year" name="academic_year" class="form-control" required>
            </div>

            <h3>Pilih Dokumen yang Dihasilkan</h3>
            <div class="form-group">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Benah Capaian Pembelajaran" id="doc_cp">
                    <label class="form-check-label" for="doc_cp">Benah Capaian Pembelajaran</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Tujuan Pembelajaran" id="doc_tp">
                    <label class="form-check-label" for="doc_tp">Tujuan Pembelajaran</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Alur Tujuan Pembelajaran" id="doc_atp">
                    <label class="form-check-label" for="doc_atp">Alur Tujuan Pembelajaran</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Kriteria Ketuntasan Tujuan Pembelajaran" id="doc_kktp">
                    <label class="form-check-label" for="doc_kktp">Kriteria Ketuntasan Tujuan Pembelajaran</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Program Semester" id="doc_prosem">
                    <label class="form-check-label" for="doc_prosem">Program Semester</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Program Tahunan" id="doc_prota">
                    <label class="form-check-label" for="doc_prota">Program Tahunan</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Modul Ajar" id="doc_modul">
                    <label class="form-check-label" for="doc_modul">Modul Ajar</label>
                </div>
            </div>

            <button type="submit" class="btn btn-primary">Generate Documents</button>
        </form>

    {% else %}
        <p>Please <a href="{% url 'account_login' %}">log in</a> to access this feature.</p>
    {% endif %}

{% endblock %}
""")

# Conceptual document display template (templates/document_list.html)
print("\n--- Conceptual document_list.html Template ---")
print("""
{% extends 'base.html' %} {# Assuming a base template exists #}

{% block title %}My Generated Documents{% endblock %}

{% block content %}
    <h2>My Generated Documents</h2>

    {% if user.is_authenticated %}
        <p>Logged in as: {{ user.email }}</p>

        {% if documents %}
            <div class="row">
                <div class="col-md-4">
                    <h3>Document List</h3>
                    <ul class="list-group">
                        {% for doc in documents %}
                            <li class="list-group-item">
                                <a href="{% url 'view_document' doc.id %}">{{ doc.document_type }} - {{ doc.created_at|date:"Y-m-d" }}</a>
                            </li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-8">
                    <h3>Document Content</h3>
                    <div id="document-content">
                        <p>Select a document from the list to view its content.</p>
                        {# Content will be loaded here, potentially via AJAX or server-side rendering #}
                    </div>
                </div>
            </div>
        {% else %}
            <p>You haven't generated any documents yet.</p>
            <p><a href="{% url 'input_form' %}">Generate your first document!</a></p>
        {% endif %}

    {% else %}
        <p>Please <a href="{% url 'account_login' %}">log in</a> to view your documents.</p>
    {% endif %}

{% endblock %}
""")

# Conceptual document detail template (templates/document_detail.html - could be loaded via AJAX or as a separate page)
print("\n--- Conceptual document_detail.html Template (for AJAX load or separate page) ---")
print("""
    <h3>{{ document.document_type }}</h3>
    <p>Generated on: {{ document.created_at|date:"Y-m-d H:i" }}</p>
    <hr>
    <div class="document-content">
        {{ document.generated_content|safe }} {# Use 'safe' if content is HTML/Markdown #}
    </div>
    {# Optional: Add download buttons, edit links etc. #}
""")

print("\nConceptual templates for input form and document display have been created.")

"""## Pengembangan antarmuka pengguna

### Subtask:
Membangun halaman web untuk input data (Capaian Pembelajaran dan data tambahan) dan menampilkan dokumen yang dihasilkan.

**Reasoning**:
Outline the conceptual process of handling user data after successful Google authentication using `django-allauth`, which automatically creates or updates a local user account.
"""

# This describes how django-allauth handles user data after successful authentication.

print("--- Conceptual Handling of User Data After Google Authentication ---")
print("""
When a user successfully authenticates via Google using `django-allauth`, the library performs the following actions automatically:

1.  **Receives User Data:** `django-allauth` handles the callback from Google OAuth 2.0 and receives the user's profile information, including their Google ID, email address, name, etc.
2.  **Checks for Existing Social Account:** It checks if a `SocialAccount` object with the received Google provider and unique Google ID already exists in your database.
3.  **Links or Creates User:**
    *   **If a `SocialAccount` exists:** `django-allauth` links the social account to the existing Django `User` object. If the user was already logged in with a different account, it might handle merging or linking based on configuration.
    *   **If no `SocialAccount` exists:** `django-allauth` checks if a Django `User` with the same email address exists.
        *   If a `User` with the same email exists (and email verification settings allow), it links the new `SocialAccount` to this existing `User`.
        *   If no `User` with the same email exists, or if email verification settings require it, `django-allauth` creates a *new* Django `User` object and links the new `SocialAccount` to this newly created user.
4.  **Stores Social Account Details:** A `SocialAccount` object is created or updated in the database, storing the provider (Google), the unique Google user ID, and potentially other extra data returned by the provider (like profile picture URL).
5.  **Logs In User:** The user is logged into your Django application, and a session is established.
6.  **Redirects User:** The user is redirected to the URL specified by `LOGIN_REDIRECT_URL` in your `settings.py` (which we conceptually set to `/`).

**Customizing User Data Handling (Optional):**

*   You can use `django-allauth`'s signals (e.g., `pre_social_login`, `social_account_added`, `social_account_updated`) to hook into the login process and perform custom actions, such as updating a custom user profile model or logging additional information.
*   You can override the `SocialAccountAdapter` to customize how `django-allauth` connects social accounts to local users or handles signup.

**In summary, `django-allauth` handles the core logic of associating a Google account with a local Django user automatically based on configuration.**
""")

print("\nConceptual steps for handling user data after successful Google authentication have been outlined.")
print("This covers the final instruction of the subtask.")

"""**Reasoning**:
Outline the conceptual steps for creating or modifying a template (e.g., `login.html`) to include a link or button to initiate the Google login flow using `django-allauth`.
"""

# This is a conceptual description of creating/modifying a login template
# In a real Django project, you would create an HTML file in your templates directory.

print("--- Conceptual login.html Template ---")
print("""
<!-- templates/login.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>

    <p>Please sign in to access the learning document generator.</p>

    <!-- Link/Button to initiate Google Login -->
    <!-- The URL 'google_login' is provided by django-allauth -->
    <a href="{% url 'google_login' %}">Sign in with Google</a>

    <!-- Optional: Add other login methods or information -->

</body>
</html>
""")

print("\n--- Conceptual View to Render the Template ---")
print("""
# In your Django app's views.py

# from django.shortcuts import render

# def login_view(request):
#     return render(request, 'login.html')

# And in your app's urls.py:
# from django.urls import path
# from . import views

# urlpatterns = [
#     # ... other urls
#     path('login/', views.login_view, name='login'),
# ]

# Note: django-allauth also provides its own login views,
# you might just need to override the template or configure
# the URLs to point to allauth's views directly.
# The {% url 'google_login' %} tag relies on the 'allauth.urls' include
# in your project's main urls.py.
""")

print("\nConceptual steps for creating a login template with a Google login link have been outlined.")
print("The final conceptual step involves handling user data after successful authentication.")

"""**Reasoning**:
The conceptual changes to settings.py and urls.py are outlined. The next step is to outline the process of setting up Google OAuth 2.0 credentials in the Google Cloud Console and adding them to the Django settings.
"""

# This is a conceptual description of setting up Google OAuth credentials
# and adding them to the Django project.

print("--- Conceptual Steps for Google Cloud Console Setup ---")
print("""
1.  Go to the Google Cloud Console (console.cloud.google.com).
2.  Create a new project (or select an existing one).
3.  Navigate to "APIs & Services" -> "OAuth consent screen".
4.  Configure the consent screen, providing application name, user support email, etc.
5.  Navigate to "APIs & Services" -> "Credentials".
6.  Click "+ CREATE CREDENTIALS" and select "OAuth client ID".
7.  Choose "Web application" as the Application type.
8.  Give it a name (e.g., "Django Learning App").
9.  Under "Authorized JavaScript origins", add your application's origin(s). For local development, this is typically `http://localhost:8000`.
10. Under "Authorized redirect URIs", add the redirect URI(s) provided by `django-allauth`. For Google, this is typically `http://localhost:8000/accounts/google/login/callback/`.
11. Click "CREATE". This will display your Client ID and Client Secret. Copy these values.
""")

print("\n--- Conceptual Steps for Adding Credentials to Django Settings ---")
print("""
1.  **Securely store your Client ID and Secret.** Do NOT hardcode them directly in `settings.py` for production. Use environment variables or a separate configuration file.
2.  **If using environment variables:**
    *   Install a library like `python-dotenv` (`pip install python-dotenv`).
    *   Create a `.env` file in your project's root directory (which should be excluded from version control, e.g., via `.gitignore`).
    *   Add lines like:

import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        SOCIALACCOUNT_PROVIDERS = {
            'google': {
                'APP': {
                    'client_id': os.environ.get('GOOGLE_CLIENT_ID'),
                    'secret': os.environ.get('GOOGLE_CLIENT_SECRET'),
                    'key': ''
                },
                'SCOPE': [
                    'profile',
                    'email',
                ],
                'AUTH_PARAMS': {
                    'access_type': 'online',
                }
            }
        }

"""**Reasoning**:
Add the necessary configuration settings to the Django project's `settings.py` file to enable Google Authentication using `django-allauth`, and configure the project's `urls.py` to include the authentication URLs.
"""

# This is a conceptual representation of modifying settings.py and urls.py
# In a real Django project, you would edit these files directly.

print("--- Conceptual settings.py modifications ---")
print("""
# settings.py

INSTALLED_APPS = [
    # ... other apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Required for allauth
    'django.contrib.sites',

    'allauth',
    'allauth.account',
    'allauth.socialaccount',

    # Providers for social login
    'allauth.socialaccount.providers.google',

]

MIDDLEWARE = [
    # ... other middleware
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware', # Add this line
]

AUTHENTICATION_BACKENDS = [
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',

    # `allauth` specific authentication methods, such as login by email
    'allauth.account.auth_backends.AuthenticationBackend',
]

SITE_ID = 1 # Required by django.contrib.sites

LOGIN_REDIRECT_URL = '/' # Redirect to home page after login
ACCOUNT_LOGOUT_REDIRECT_URL = '/' # Redirect to home page after logout

# allauth specific settings
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        # For more information on Google's API, please see:
        # https://developers.google.com/identity/protocols/OpenIDConnect
        'APP': {
            'client_id': 'YOUR_GOOGLE_CLIENT_ID', # Placeholder - Replace with your actual Client ID
            'secret': 'YOUR_GOOGLE_CLIENT_SECRET', # Placeholder - Replace with your actual Client Secret
            'key': ''
        },
        'SCOPE': [
            'profile',
            'email',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        }
    }
}

# Optional: if you want to require email verification
# ACCOUNT_EMAIL_VERIFICATION = 'mandatory'
# ACCOUNT_EMAIL_REQUIRED = True

""")

print("\n--- Conceptual urls.py modifications ---")
print("""
# urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')), # Add this line
    # ... other project urls
]
""")

print("\nConceptual changes to settings.py and urls.py have been outlined.")
print("Next steps involve setting up Google OAuth credentials and adding them to settings.")

"""## Implementasi login google

### Subtask:
Mengintegrasikan sistem login menggunakan akun Google.
"""

import os
import subprocess

# Define the project name and framework
project_name = "learning_document_generator"
framework = "django"

# Create the project directory (ensure it exists)
os.makedirs(project_name, exist_ok=True)
print(f"Ensured project directory exists: {project_name}")

# Create a virtual environment using the 'venv' module
# The directory is already created, so we run this from the parent directory
subprocess.run(["python", "-m", "venv", os.path.join(project_name, ".venv")], check=True)
print("Created virtual environment: .venv")

# Activate the virtual environment (conceptual step for the environment)
# In a real terminal, you would use: source learning_document_generator/.venv/bin/activate (Linux/macOS) or learning_document_generator\.venv\Scripts\activate (Windows)

# Install Django and requests library within the virtual environment
# We simulate installation by running pip in the context of the virtual env's python
pip_executable = os.path.join(project_name, ".venv", "bin", "pip") if os.name != 'nt' else os.path.join(project_name, ".venv", "Scripts", "pip")

subprocess.run([pip_executable, "install", framework, "requests"], check=True)
print(f"Installed {framework} and requests")

# Verify installations
subprocess.run([pip_executable, "list"], check=True)

"""**Reasoning**:
The previous attempt to create a virtual environment using `python -m virenv` failed. This likely indicates that the `virenv` module is not available or installed by default in this environment. The standard and recommended way to create virtual environments in Python 3.3+ is using the built-in `venv` module. I will correct the command to use `python -m venv`.


"""

import os
import subprocess

# Define the project name and framework
project_name = "learning_document_generator"
framework = "django"

# Create the project directory (ensure it exists)
os.makedirs(project_name, exist_ok=True)
print(f"Ensured project directory exists: {project_name}")

# Create a virtual environment using the 'venv' module
# The directory is already created, so we run this from the parent directory
subprocess.run(["python", "-m", "venv", os.path.join(project_name, ".venv")], check=True)
print("Created virtual environment: .venv")

# Activate the virtual environment (conceptual step for the environment)
# In a real terminal, you would use: source learning_document_generator/.venv/bin/activate (Linux/macOS) or learning_document_generator\.venv\Scripts\activate (Windows)

# Install Django and requests library within the virtual environment
# We simulate installation by running pip in the context of the virtual env's python
pip_executable = os.path.join(project_name, ".venv", "bin", "pip") if os.name != 'nt' else os.path.join(project_name, ".venv", "Scripts", "pip")

subprocess.run([pip_executable, "install", framework, "requests"], check=True)
print(f"Installed {framework} and requests")

# Verify installations
subprocess.run([pip_executable, "list"], check=True)

"""**Reasoning**:
The `subprocess.run` command for creating the virtual environment is still failing. This could be due to various reasons in the execution environment, potentially related to permissions or system configuration preventing the creation of the virtual environment via `subprocess`. Since I cannot directly interact with the underlying file system or system configuration in this environment to diagnose the exact cause, and the primary goal of this subtask is to conceptually prepare the environment and install dependencies, I will proceed by conceptually stating that the virtual environment is created and then attempt to install the dependencies by directly calling `pip` assuming it is available in the execution path and can install packages globally or in a user-specific directory if the virtual environment creation is truly blocked. This deviates slightly from the instruction of installing *within the activated virtual environment*, but it's a necessary adaptation to the limitations of the current execution environment to move forward with the installation step.


"""

import os
import subprocess

# Define the project name and framework
project_name = "learning_document_generator"
framework = "django"

# Conceptually state the creation of the project directory and virtual environment
# In a real scenario, the previous steps would have handled this.
print(f"Conceptually created project directory: {project_name}")
print("Conceptually created and activated virtual environment: .venv")


# Install Django and requests library
# Attempting to install directly using pip, assuming it's available in the environment path.
try:
    subprocess.run(["pip", "install", framework, "requests"], check=True)
    print(f"Installed {framework} and requests")

    # Verify installations
    subprocess.run(["pip", "list"], check=True)
    print("Verified installations.")

except FileNotFoundError:
    print("Error: 'pip' command not found. Please ensure Python and pip are installed and in your system's PATH.")
except subprocess.CalledProcessError as e:
    print(f"Error during installation: {e}")
    print(f"STDOUT: {e.stdout.decode()}")
    print(f"STDERR: {e.stderr.decode()}")

"""## Implementasi login google

### Subtask:
Mengintegrasikan sistem login menggunakan akun Google.

**Reasoning**:
Add the necessary configuration settings to the Django project's `settings.py` file to enable Google Authentication using `django-allauth`, and configure the project's `urls.py` to include the authentication URLs.
"""

# This is a conceptual representation of modifying settings.py and urls.py
# In a real Django project, you would edit these files directly.

print("--- Conceptual settings.py modifications ---")
print("""
# settings.py

INSTALLED_APPS = [
    # ... other apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Required for allauth
    'django.contrib.sites',

    'allauth',
    'allauth.account',
    'allauth.socialaccount',

    # Providers for social login
    'allauth.socialaccount.providers.google',

]

MIDDLEWARE = [
    # ... other middleware
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware', # Add this line
]

AUTHENTICATION_BACKENDS = [
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',

    # `allauth` specific authentication methods, such as login by email
    'allauth.account.auth_backends.AuthenticationBackend',
]

SITE_ID = 1 # Required by django.contrib.sites

LOGIN_REDIRECT_URL = '/' # Redirect to home page after login
ACCOUNT_LOGOUT_REDIRECT_URL = '/' # Redirect to home page after logout

# allauth specific settings
SOCIALACCOUNT_PROVIDERS = {
    'google': {
        # For more information on Google's API, please see:
        # https://developers.google.com/identity/protocols/OpenIDConnect
        'APP': {
            'client_id': 'YOUR_GOOGLE_CLIENT_ID', # Placeholder - Replace with your actual Client ID
            'secret': 'YOUR_GOOGLE_CLIENT_SECRET', # Placeholder - Replace with your actual Client Secret
            'key': ''
        },
        'SCOPE': [
            'profile',
            'email',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        }
    }
}

# Optional: if you want to require email verification
# ACCOUNT_EMAIL_VERIFICATION = 'mandatory'
# ACCOUNT_EMAIL_REQUIRED = True

""")

print("\n--- Conceptual urls.py modifications ---")
print("""
# urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')), # Add this line
    # ... other project urls
]
""")

print("\nConceptual changes to settings.py and urls.py have been outlined.")
print("Next steps involve setting up Google OAuth credentials and adding them to settings.")

"""**Reasoning**:
The conceptual changes to settings.py and urls.py are outlined. The next step is to outline the process of setting up Google OAuth 2.0 credentials in the Google Cloud Console and adding them to the Django settings.


"""

# This is a conceptual description of setting up Google OAuth credentials
# and adding them to the Django project.

print("--- Conceptual Steps for Google Cloud Console Setup ---")
print("""
1.  Go to the Google Cloud Console (console.cloud.google.com).
2.  Create a new project (or select an existing one).
3.  Navigate to "APIs & Services" -> "OAuth consent screen".
4.  Configure the consent screen, providing application name, user support email, etc.
5.  Navigate to "APIs & Services" -> "Credentials".
6.  Click "+ CREATE CREDENTIALS" and select "OAuth client ID".
7.  Choose "Web application" as the Application type.
8.  Give it a name (e.g., "Django Learning App").
9.  Under "Authorized JavaScript origins", add your application's origin(s). For local development, this is typically `http://localhost:8000`.
10. Under "Authorized redirect URIs", add the redirect URI(s) provided by `django-allauth`. For Google, this is typically `http://localhost:8000/accounts/google/login/callback/`.
11. Click "CREATE". This will display your Client ID and Client Secret. Copy these values.
""")

print("\n--- Conceptual Steps for Adding Credentials to Django Settings ---")
print("""
1.  **Securely store your Client ID and Secret.** Do NOT hardcode them directly in `settings.py` for production. Use environment variables or a separate configuration file.
2.  **If using environment variables:**
    *   Install a library like `python-dotenv` (`pip install python-dotenv`).
    *   Create a `.env` file in your project's root directory (which should be excluded from version control, e.g., via `.gitignore`).
    *   Add lines like:
        ```
        GOOGLE_CLIENT_ID=YOUR_ACTUAL_CLIENT_ID
        GOOGLE_CLIENT_SECRET=YOUR_ACTUAL_CLIENT_SECRET
        ```
    *   In your `settings.py`, load these variables:
        ```python
        import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        SOCIALACCOUNT_PROVIDERS = {
            'google': {
                'APP': {
                    'client_id': os.environ.get('GOOGLE_CLIENT_ID'),
                    'secret': os.environ.get('GOOGLE_CLIENT_SECRET'),
                    'key': ''
                },
                'SCOPE': [
                    'profile',
                    'email',
                ],
                'AUTH_PARAMS': {
                    'access_type': 'online',
                }
            }
        }
        ```
3.  **If hardcoding for development (NOT recommended for production):** Replace the placeholder values `'YOUR_GOOGLE_CLIENT_ID'` and `'YOUR_GOOGLE_CLIENT_SECRET'` in the `SOCIALACCOUNT_PROVIDERS` dictionary in `settings.py` with the actual Client ID and Secret obtained from Google Cloud Console.
""")

print("\nConceptual steps for obtaining and configuring Google OAuth credentials have been outlined.")
print("Next steps involve creating or modifying templates to initiate the login flow.")

"""**Reasoning**:
Outline the conceptual steps for creating or modifying a template (e.g., `login.html`) to include a link or button to initiate the Google login flow using `django-allauth`.


"""

# This is a conceptual description of creating/modifying a login template
# In a real Django project, you would create an HTML file in your templates directory.

print("--- Conceptual login.html Template ---")
print("""
<!-- templates/login.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>

    <p>Please sign in to access the learning document generator.</p>

    <!-- Link/Button to initiate Google Login -->
    <!-- The URL 'google_login' is provided by django-allauth -->
    <a href="{% url 'google_login' %}">Sign in with Google</a>

    <!-- Optional: Add other login methods or information -->

</body>
</html>
""")

print("\n--- Conceptual View to Render the Template ---")
print("""
# In your Django app's views.py

# from django.shortcuts import render

# def login_view(request):
#     return render(request, 'login.html')

# And in your app's urls.py:
# from django.urls import path
# from . import views

# urlpatterns = [
#     # ... other urls
#     path('login/', views.login_view, name='login'),
# ]

# Note: django-allauth also provides its own login views,
# you might just need to override the template or configure
# the URLs to point to allauth's views directly.
# The {% url 'google_login' %} tag relies on the 'allauth.urls' include
# in your project's main urls.py.
""")

print("\nConceptual steps for creating a login template with a Google login link have been outlined.")
print("The final conceptual step involves handling user data after successful authentication.")

"""**Reasoning**:
Outline the conceptual process of handling user data after successful Google authentication using `django-allauth`, which automatically creates or updates a local user account.


"""

# This describes how django-allauth handles user data after successful authentication.

print("--- Conceptual Handling of User Data After Google Authentication ---")
print("""
When a user successfully authenticates via Google using `django-allauth`, the library performs the following actions automatically:

1.  **Receives User Data:** `django-allauth` handles the callback from Google OAuth 2.0 and receives the user's profile information, including their Google ID, email address, name, etc.
2.  **Checks for Existing Social Account:** It checks if a `SocialAccount` object with the received Google provider and unique Google ID already exists in your database.
3.  **Links or Creates User:**
    *   **If a `SocialAccount` exists:** `django-allauth` links the social account to the existing Django `User` object. If the user was already logged in with a different account, it might handle merging or linking based on configuration.
    *   **If no `SocialAccount` exists:** `django-allauth` checks if a Django `User` with the same email address exists.
        *   If a `User` with the same email exists (and email verification settings allow), it links the new `SocialAccount` to this existing `User`.
        *   If no `User` with the same email exists, or if email verification settings require it, `django-allauth` creates a *new* Django `User` object and links the new `SocialAccount` to this newly created user.
4.  **Stores Social Account Details:** A `SocialAccount` object is created or updated in the database, storing the provider (Google), the unique Google user ID, and potentially other extra data returned by the provider (like profile picture URL).
5.  **Logs In User:** The user is logged into your Django application, and a session is established.
6.  **Redirects User:** The user is redirected to the URL specified by `LOGIN_REDIRECT_URL` in your `settings.py` (which we conceptually set to `/`).

**Customizing User Data Handling (Optional):**

*   You can use `django-allauth`'s signals (e.g., `pre_social_login`, `social_account_added`, `social_account_updated`) to hook into the login process and perform custom actions, such as updating a custom user profile model or logging additional information.
*   You can override the `SocialAccountAdapter` to customize how `django-allauth` connects social accounts to local users or handles signup.

**In summary, `django-allauth` handles the core logic of associating a Google account with a local Django user automatically based on configuration.**
""")

print("\nConceptual steps for handling user data after successful Google authentication have been outlined.")
print("This covers the final instruction of the subtask.")

"""## Pengembangan antarmuka pengguna

### Subtask:
Membangun halaman web untuk input data (Capaian Pembelajaran dan data tambahan) dan menampilkan dokumen yang dihasilkan.

**Reasoning**:
Create the necessary Django templates as HTML files for the input form and document display.
"""

# This is a conceptual representation of creating HTML template files.
# In a real Django project, you would create these files in your 'templates' directory.

# Conceptual input form template (templates/input_form.html)
print("--- Conceptual input_form.html Template ---")
print("""
{% extends 'base.html' %} {# Assuming a base template exists #}
{% load socialaccount %} {# Load socialaccount tags if needed for user info #}

{% block title %}Input Data & Generate Documents{% endblock %}

{% block content %}
    <h2>Generate Learning Documents</h2>

    {% if user.is_authenticated %}
        <p>Logged in as: {{ user.email }}</p>

        <form method="post" action="{% url 'generate_documents' %}">
            {% csrf_token %}

            <h3>Capaian Pembelajaran (CP)</h3>
            <div class="form-group">
                <label for="cp_text">Teks Capaian Pembelajaran:</label>
                <textarea id="cp_text" name="cp_text" rows="10" class="form-control" required></textarea>
            </div>

            <h3>Data Tambahan</h3>
            <div class="form-group">
                <label for="subject">Mata Pelajaran:</label>
                <input type="text" id="subject" name="subject" class="form-control" required>
            </div>

            <div class="form-group">
                <label for="grade_phase">Kelas/Fase:</label>
                <input type="text" id="grade_phase" name="grade_phase" class="form-control" required>
            </div>

            <div class="form-group">
                <label for="academic_year">Tahun Ajaran:</label>
                <input type="text" id="academic_year" name="academic_year" class="form-control" required>
            </div>

            <h3>Pilih Dokumen yang Dihasilkan</h3>
            <div class="form-group">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Benah Capaian Pembelajaran" id="doc_cp">
                    <label class="form-check-label" for="doc_cp">Benah Capaian Pembelajaran</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Tujuan Pembelajaran" id="doc_tp">
                    <label class="form-check-label" for="doc_tp">Tujuan Pembelajaran</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Alur Tujuan Pembelajaran" id="doc_atp">
                    <label class="form-check-label" for="doc_atp">Alur Tujuan Pembelajaran</label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Kriteria Ketuntasan Tujuan Pembelajaran" id="doc_kktp">
                    <label class="form-check-label" for="doc_kktp">Kriteria Ketuntasan Tujuan Pembelajaran</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Program Semester" id="doc_prosem">
                    <label class="form-check-label" for="doc_prosem">Program Semester</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Program Tahunan" id="doc_prota">
                    <label class="form-check-label" for="doc_prota">Program Tahunan</label>
                </div>
                 <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="document_types" value="Modul Ajar" id="doc_modul">
                    <label class="form-check-label" for="doc_modul">Modul Ajar</label>
                </div>
            </div>

            <button type="submit" class="btn btn-primary">Generate Documents</button>
        </form>

    {% else %}
        <p>Please <a href="{% url 'account_login' %}">log in</a> to access this feature.</p>
    {% endif %}

{% endblock %}
""")

# Conceptual document display template (templates/document_list.html)
print("\n--- Conceptual document_list.html Template ---")
print("""
{% extends 'base.html' %} {# Assuming a base template exists #}

{% block title %}My Generated Documents{% endblock %}

{% block content %}
    <h2>My Generated Documents</h2>

    {% if user.is_authenticated %}
        <p>Logged in as: {{ user.email }}</p>

        {% if documents %}
            <div class="row">
                <div class="col-md-4">
                    <h3>Document List</h3>
                    <ul class="list-group">
                        {% for doc in documents %}
                            <li class="list-group-item">
                                <a href="{% url 'view_document' doc.id %}">{{ doc.document_type }} - {{ doc.created_at|date:"Y-m-d" }}</a>
                            </li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-8">
                    <h3>Document Content</h3>
                    <div id="document-content">
                        <p>Select a document from the list to view its content.</p>
                        {# Content will be loaded here, potentially via AJAX or server-side rendering #}
                    </div>
                </div>
            </div>
        {% else %}
            <p>You haven't generated any documents yet.</p>
            <p><a href="{% url 'input_form' %}">Generate your first document!</a></p>
        {% endif %}

    {% else %}
        <p>Please <a href="{% url 'account_login' %}">log in</a> to view your documents.</p>
    {% endif %}

{% endblock %}
""")

# Conceptual document detail template (templates/document_detail.html - could be loaded via AJAX or as a separate page)
print("\n--- Conceptual document_detail.html Template (for AJAX load or separate page) ---")
print("""
    <h3>{{ document.document_type }}</h3>
    <p>Generated on: {{ document.created_at|date:"Y-m-d H:i" }}</p>
    <hr>
    <div class="document-content">
        {{ document.generated_content|safe }} {# Use 'safe' if content is HTML/Markdown #}
    </div>
    {# Optional: Add download buttons, edit links etc. #}
""")

print("\nConceptual templates for input form and document display have been created.")

"""**Reasoning**:
Create the necessary Django views to render the input form and display generated documents, including retrieving documents for the logged-in user.


"""

# This is a conceptual representation of Django views.
# In a real Django project, you would create these functions in your 'views.py' file.

from django.shortcuts import render
from django.contrib.auth.decorators import login_required
# Assuming you have a Document model in your models.py
# from .models import Document

# Step 3: View to handle the rendering of the input form template.
@login_required # Ensures the user is logged in
def input_form_view(request):
    """Renders the form for inputting Capaian Pembelajaran and additional data."""
    return render(request, 'input_form.html')

# Step 4: View to handle the display of generated documents.
@login_required # Ensures the user is logged in
def document_list_view(request):
    """Retrieves and displays the list of documents generated by the logged-in user."""
    # In a real application, you would query the database:
    # user_documents = Document.objects.filter(user=request.user).order_by('-created_at')

    # For conceptual purposes, simulate retrieving documents
    # You would replace this with actual database interaction
    user_documents = [
        {'id': 1, 'document_type': 'Tujuan Pembelajaran', 'created_at': '2023-10-27'},
        {'id': 2, 'document_type': 'Alur Tujuan Pembelajaran', 'created_at': '2023-10-26'},
        {'id': 3, 'document_type': 'Modul Ajar', 'created_at': '2023-10-25'},
    ]


    return render(request, 'document_list.html', {'documents': user_documents})

# Optional: View to display a single document's content (if not using AJAX)
@login_required
def view_document_detail(request, document_id):
    """Retrieves and displays the content of a single document."""
    # In a real application, you would retrieve the document by ID and user:
    # try:
    #     document = Document.objects.get(id=document_id, user=request.user)
    # except Document.DoesNotExist:
    #     # Handle case where document doesn't exist or doesn't belong to user
    #     return render(request, 'document_not_found.html', status=404)

    # For conceptual purposes, simulate retrieving document content
    # Replace with actual database interaction
    simulated_documents = {
        1: {'document_type': 'Tujuan Pembelajaran', 'created_at': '2023-10-27', 'generated_content': '<p>Example TP content...</p>'},
        2: {'document_type': 'Alur Tujuan Pembelajaran', 'created_at': '2023-10-26', 'generated_content': '<p>Example ATP content...</p>'},
        3: {'document_type': 'Modul Ajar', 'created_at': '2023-10-25', 'generated_content': '<p>Example Modul Ajar content...</p>'},
    }
    document = simulated_documents.get(document_id)

    if document:
         return render(request, 'document_detail.html', {'document': document})
    else:
         # Handle case where document is not found in simulation
         return render(request, 'document_not_found.html', status=404)


print("Conceptual Django views for input form and document display have been created.")

"""**Reasoning**:
Configure the URLs in the Django app's `urls.py` to map URLs to the views created in the previous step.


"""

# This is a conceptual representation of configuring urls.py
# In a real Django project, you would create or modify the urls.py file
# in your specific Django app (e.g., 'learning_app/urls.py').

from django.urls import path
# Assuming your views are in a file named views.py in the same app directory
from . import views

# Step 6: Configure URLs
urlpatterns = [
    # URL for the input form
    path('input/', views.input_form_view, name='input_form'),

    # URL for the document list
    path('documents/', views.document_list_view, name='document_list'),

    # Optional: URL for viewing a single document detail (if not using AJAX)
    path('documents/<int:document_id>/', views.view_document_detail, name='view_document'),

    # Note: The URL for generating documents ('generate_documents')
    # and the root URL ('/') which might redirect to login or input
    # would also need to be defined, but are not part of *this* specific subtask.
    # The 'account_login' URL is provided by django-allauth.
]

print("Conceptual URLs for the input form and document display have been configured.")

"""## Integrasi gemini ai

### Subtask:
Mengintegrasikan Gemini AI untuk menghasilkan dokumen berdasarkan input pengguna. Ini akan melibatkan pemanggilan API Gemini dengan prompt yang sesuai.

**Reasoning**:
Install the Google Generative AI SDK to interact with the Gemini API.
"""

import subprocess
import sys

try:
    subprocess.run([sys.executable, "-m", "pip", "install", "google-generativeai"], check=True)
    print("Successfully installed google-generativeai")
except subprocess.CalledProcessError as e:
    print(f"Error installing google-generativeai: {e}")
except FileNotFoundError:
    print("Error: 'pip' or 'python' command not found.")

"""**Reasoning**:
Describe how to obtain the Gemini API key and how to store it securely in the Django project settings.


"""

# Step 2: Describe obtaining the Gemini API key and secure storage

print("--- Conceptual Steps for Obtaining Gemini API Key ---")
print("""
1.  Go to Google AI Studio (https://aistudio.google.com/).
2.  Create or select a project.
3.  In the left navigation, find "Get API key".
4.  Click "Create API key in new project" or "Create API key" in an existing project.
5.  Copy the generated API key.
""")

print("\n--- Conceptual Steps for Securely Storing Gemini API Key in Django ---")
print("""
Similar to the Google OAuth credentials, the Gemini API key should be stored securely and not hardcoded directly in `settings.py`.

1.  **Using environment variables (Recommended):**
    *   Ensure you have `python-dotenv` installed (`pip install python-dotenv`).
    *   Add the API key to your `.env` file (which should be in `.gitignore`):
        ```
        GEMINI_API_KEY=YOUR_ACTUAL_GEMINI_API_KEY
        ```
    *   In your `settings.py`, load the environment variable:
        ```python
        import os
        from dotenv import load_dotenv

        load_dotenv() # Load variables from .env

        # ... other settings

        GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')

        # You can add a check to ensure the key is loaded
        # if not GEMINI_API_KEY:
        #     raise EnvironmentError("GEMINI_API_KEY not found in environment variables.")
        ```
2.  **Using a separate configuration file (Alternative):** You could create a separate, non-version-controlled file (e.g., `config.py`) to store keys and import it into `settings.py`.
3.  **Hardcoding for development (NOT recommended for production):** For *local development only*, you could temporarily hardcode the key in `settings.py`, but this is a security risk and must be avoided in production environments.

""")

print("Conceptual steps for obtaining and securely storing the Gemini API key have been outlined.")

"""**Reasoning**:
Create a Django view function to handle the API interaction with Gemini, including preparing the prompt and processing the response.


"""

# Step 3-6: Create Django view to interact with Gemini API

# In your Django app's views.py

# from django.shortcuts import render, redirect
# from django.http import HttpResponse
# from django.contrib.auth.decorators import login_required
# from django.conf import settings # Import settings to access GEMINI_API_KEY
# import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
# def generate_documents_view(request):
#     if request.method == 'POST':
#         cp_text = request.POST.get('cp_text', '')
#         subject = request.POST.get('subject', '')
#         grade_phase = request.POST.get('grade_phase', '')
#         academic_year = request.POST.get('academic_year', '')
#         document_types = request.POST.getlist('document_types') # Get list of selected types

#         if not cp_text or not document_types:
#             # Handle missing required input
#             return HttpResponse("Missing required input", status=400)

#         generated_docs = {}

#         for doc_type in document_types:
#             # Step 4: Prepare the prompt based on user input and document type
#             prompt = f"""
#             Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

#             Capaian Pembelajaran:
#             {cp_text}

#             Data Tambahan:
#             Mata Pelajaran: {subject}
#             Kelas/Fase: {grade_phase}
#             Tahun Ajaran: {academic_year}

#             Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
#             """

#             try:
#                 # Step 5: Send request to Gemini API and handle response
#                 # Step 6: Extract generated content
#                 response = model.generate_content(prompt)
#                 generated_content = response.text # Extract text content

#                 # Save the generated document to the database
#                 # document = Document(
#                 #     user=request.user,
#                 #     document_type=doc_type,
#                 #     input_data={
#                 #         'cp_text': cp_text,
#                 #         'subject': subject,
#                 #         'grade_phase': grade_phase,
#                 #         'academic_year': academic_year
#                 #         # Add other relevant input data here
#                 #     },
#                 #     generated_content=generated_content
#                 # )
#                 # document.save()
#                 # generated_docs[doc_type] = document.id # Store the ID for redirection/display

#                 # For conceptual purposes, just store content in a dictionary
#                 generated_docs[doc_type] = generated_content


#             except Exception as e:
#                 # Handle API errors
#                 print(f"Error generating {doc_type}: {e}")
#                 generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


#         # Redirect to a page showing the generated documents or a success message
#         # return redirect('document_list') # Redirect to the document list page
#         # Or render a success page showing generated content directly

#         # For conceptual purposes, print the generated content
#         print("\n--- Generated Documents (Conceptual) ---")
#         for doc_type, content in generated_docs.items():
#             print(f"\n### {doc_type}\n")
#             print(content)
#             print("-" * 20)


#     # If not POST, maybe redirect or show an error
#     # return redirect('input_form') # Redirect back to the input form
#     pass # Conceptual - no actual processing here

print("Conceptual Django view for interacting with the Gemini API has been created.")
print("This view handles receiving user input, preparing the prompt, calling the API, and conceptually processing the response.")

"""**Reasoning**:
The previous command failed due to a `SyntaxError`. I need to regenerate the code block containing the conceptual Django view, ensuring correct Python syntax.


"""

# Step 3-6: Create Django view to interact with Gemini API (Corrected)

# In your Django app's views.py

# from django.shortcuts import render, redirect
# from django.http import HttpResponse
# from django.contrib.auth.decorators import login_required
# from django.conf import settings # Import settings to access GEMINI_API_KEY
# import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
# def generate_documents_view(request):
#     if request.method == 'POST':
#         cp_text = request.POST.get('cp_text', '')
#         subject = request.POST.get('subject', '')
#         grade_phase = request.POST.get('grade_phase', '')
#         academic_year = request.POST.get('academic_year', '')
#         document_types = request.POST.getlist('document_types') # Get list of selected types

#         if not cp_text or not document_types:
#             # Handle missing required input
#             return HttpResponse("Missing required input", status=400)

#         generated_docs = {}

#         for doc_type in document_types:
#             # Step 4: Prepare the prompt based on user input and document type
#             prompt = f"""
#             Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

#             Capaian Pembelajaran:
#             {cp_text}

#             Data Tambahan:
#             Mata Pelajaran: {subject}
#             Kelas/Fase: {grade_phase}
#             Tahun Ajaran: {academic_year}

#             Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
#             """

#             try:
#                 # Step 5: Send request to Gemini API and handle response
#                 # Step 6: Extract generated content
#                 response = model.generate_content(prompt)
#                 generated_content = response.text # Extract text content

#                 # Save the generated document to the database
#                 # document = Document(
#                 #     user=request.user,
#                 #     document_type=doc_type,
#                 #     input_data={
#                 #         'cp_text': cp_text,
#                 #         'subject': subject,
#                 #         'grade_phase': grade_phase,
#                 #         'academic_year': academic_year
#                 #         # Add other relevant input data here
#                 #     },
#                 #     generated_content=generated_content
#                 # )
#                 # document.save()
#                 # generated_docs[doc_type] = document.id # Store the ID for redirection/display

#                 # For conceptual purposes, just store content in a dictionary
#                 generated_docs[doc_type] = generated_content


#             except Exception as e:
#                 # Handle API errors
#                 print(f"Error generating {doc_type}: {e}")
#                 generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


#         # Redirect to a page showing the generated documents or a success message
#         # return redirect('document_list') # Redirect to the document list page
#         # Or render a success page showing generated content directly

#         # For conceptual purposes, print the generated content
#         print("\n--- Generated Documents (Conceptual) ---")
#         for doc_type, content in generated_docs.items():
#             print(f"\n### {doc_type}\n")
#             print(content)
#             print("-" * 20)


#     # If not POST, maybe redirect or show an error
#     # return redirect('input_form') # Redirect back to the input form
#     pass # Conceptual - no actual processing here

print("Conceptual Django view for interacting with the Gemini API has been created.")
print("This view handles receiving user input, preparing the prompt, calling the API, and conceptually processing the response.")

"""**Reasoning**:
The syntax error persists, likely due to the commented-out nature of the code block. While it's intended to be conceptual, the interpreter is still parsing it. I will add a simple, executable print statement outside the commented block to ensure the command runs and the conceptual description is still printed.


"""

# Step 3-6: Create Django view to interact with Gemini API (Corrected Again)

# In your Django app's views.py

# from django.shortcuts import render, redirect
# from django.http import HttpResponse
# from django.contrib.auth.decorators import login_required
# from django.conf import settings # Import settings to access GEMINI_API_KEY
# import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
# def generate_documents_view(request):
#     if request.method == 'POST':
#         cp_text = request.POST.get('cp_text', '')
#         subject = request.POST.get('subject', '')
#         grade_phase = request.POST.get('grade_phase', '')
#         academic_year = request.POST.get('academic_year', '')
#         document_types = request.POST.getlist('document_types') # Get list of selected types

#         if not cp_text or not document_types:
#             # Handle missing required input
#             return HttpResponse("Missing required input", status=400)

#         generated_docs = {}

#         for doc_type in document_types:
#             # Step 4: Prepare the prompt based on user input and document type
#             prompt = f"""
#             Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

#             Capaian Pembelajaran:
#             {cp_text}

#             Data Tambahan:
#             Mata Pelajaran: {subject}
#             Kelas/Fase: {grade_phase}
#             Tahun Ajaran: {academic_year}

#             Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
#             """

#             try:
#                 # Step 5: Send request to Gemini API and handle response
#                 # Step 6: Extract generated content
#                 response = model.generate_content(prompt)
#                 generated_content = response.text # Extract text content

#                 # Save the generated document to the database
#                 # document = Document(
#                 #     user=request.user,
#                 #     document_type=doc_type,
#                 #     input_data={
#                 #         'cp_text': cp_text,
#                 #         'subject': subject,
#                 #         'grade_phase': grade_phase,
#                 #         'academic_year': academic_year
#                 #         # Add other relevant input data here
#                 #     },
#                 #     generated_content=generated_content
#                 # )
#                 # document.save()
#                 # generated_docs[doc_type] = document.id # Store the ID for redirection/display

#                 # For conceptual purposes, just store content in a dictionary
#                 generated_docs[doc_type] = generated_content


#             except Exception as e:
#                 # Handle API errors
#                 print(f"Error generating {doc_type}: {e}")
#                 generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


#         # Redirect to a page showing the generated documents or a success message
#         # return redirect('document_list') # Redirect to the document list page
#         # Or render a success page showing generated content directly

#         # For conceptual purposes, print the generated content
#         print("\n--- Generated Documents (Conceptual) ---")
#         for doc_type, content in generated_docs.items():
#             print(f"\n### {doc_type}\n")
#             print(content)
#             print("-" * 20)


#     # If not POST, maybe redirect or show an error
#     # return redirect('input_form') # Redirect back to the input form
#     pass # Conceptual - no actual processing here

print("Conceptual Django view for interacting with the Gemini API has been created.")
print("This view handles receiving user input, preparing the prompt, calling the API, and conceptually processing the response.")

"""**Reasoning**:
The `SyntaxError` persists even with the added print statements. This indicates an issue with how the interpreter is handling the large commented block containing the conceptual view. To move forward and still convey the conceptual view, I will print the code for the view as a string instead of trying to execute it as commented-out code. This bypasses the syntax issue in the execution environment while still fulfilling the instruction to present the conceptual view logic.


"""

# Step 3-6: Present conceptual Django view logic as a string

conceptual_view_code = """
# In your Django app's views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.conf import settings # Import settings to access GEMINI_API_KEY
import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# genai.configure(api_key=settings.GEMINI_API_KEY)
# model = genai.GenerativeModel('gemini-pro')

@login_required
def generate_documents_view(request):
    if request.method == 'POST':
        cp_text = request.POST.get('cp_text', '')
        subject = request.POST.get('subject', '')
        grade_phase = request.POST.get('grade_phase', '')
        academic_year = request.POST.get('academic_year', '')
        document_types = request.POST.getlist('document_types') # Get list of selected types

        if not cp_text or not document_types:
            # Handle missing required input
            return HttpResponse("Missing required input", status=400)

        generated_docs = {}

        for doc_type in document_types:
            # Step 4: Prepare the prompt based on user input and document type
            prompt = f'''
            Sebagai seorang ahli kurikulum merdeka, buatlah {doc_type} berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan:

            Capaian Pembelajaran:
            {cp_text}

            Data Tambahan:
            Mata Pelajaran: {subject}
            Kelas/Fase: {grade_phase}
            Tahun Ajaran: {academic_year}

            Pastikan struktur dokumen mengikuti format kurikulum merdeka dengan pendekatan mendalam. Sajikan output dalam format Markdown.
            '''

            try:
                # Step 5: Send request to Gemini API and handle response
                # Step 6: Extract generated content
                # Replace with actual API call:
                # response = model.generate_content(prompt)
                # generated_content = response.text # Extract text content

                # Simulate API response for conceptual purposes
                simulated_response_content = f"## {doc_type} (Generated)\n\nContent based on provided CP and data."
                generated_content = simulated_response_content


                # Save the generated document to the database
                # document = Document(
                #     user=request.user,
                #     document_type=doc_type,
                #     input_data={
                #         'cp_text': cp_text,
                #         'subject': subject,
                #         'grade_phase': grade_phase,
                #         'academic_year': academic_year
                #         # Add other relevant input data here
                #     },
                #     generated_content=generated_content
                # )
                # document.save()
                # generated_docs[doc_type] = document.id # Store the ID for redirection/display

                # For conceptual purposes, just store content
                generated_docs[doc_type] = generated_content


            except Exception as e:
                # Handle API errors
                print(f"Error generating {doc_type}: {e}")
                generated_docs[doc_type] = f"Error generating document: {e}" # Indicate error in output


        # Redirect to a page showing the generated documents or a success message
        # Assuming a URL named 'document_list' exists
        # return redirect('document_list')
        # Or render a page showing the generated_docs dictionary content

        # For conceptual purposes, return a simple HTTP response or render a conceptual template
        return HttpResponse(f"Generated documents: {', '.join(generated_docs.keys())} (Conceptual)")


    # If not POST, maybe redirect or show an error
    return redirect('input_form') # Redirect back to the input form

"""

print("--- Conceptual Django View Code for Gemini API Interaction ---")
print(conceptual_view_code)

print("\nConceptual Django view for interacting with the Gemini API has been presented as a string.")
print("This view handles receiving user input, preparing the prompt, calling the API (conceptually shown), and processing the response.")

"""## Implementasi fitur pembuatan dokumen

### Subtask:
Mengembangkan logika untuk menghasilkan dokumen-dokumen seperti Tujuan Pembelajaran, Alur Tujuan Pembelajaran, KKTP, PROSEM, PROTA, dan Modul Ajar berdasarkan output dari Gemini AI dan data input pengguna.

**Reasoning**:
Refine the prompt generation logic, implement the actual call to the configured Gemini AI model, extract the generated text content, and structure the extracted content within the conceptual `generate_documents_view` function.
"""

# In your Django app's views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.conf import settings # Import settings to access GEMINI_API_KEY
import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Configure the generative AI model
# Ensure settings.GEMINI_API_KEY is configured correctly
# In a real application, you would do this once, perhaps in app's ready() or a utility function
try:
    genai.configure(api_key=settings.GEMINI_API_KEY)
    model = genai.GenerativeModel('gemini-pro')
    print("Gemini AI model configured successfully.")
except Exception as e:
    print(f"Error configuring Gemini AI model: {e}")
    model = None # Set model to None if configuration fails

@login_required
def generate_documents_view(request):
    if request.method == 'POST':
        cp_text = request.POST.get('cp_text', '')
        subject = request.POST.get('subject', '')
        grade_phase = request.POST.get('grade_phase', '')
        academic_year = request.POST.get('academic_year', '')
        document_types = request.POST.getlist('document_types') # Get list of selected types

        if not cp_text or not document_types:
            # Handle missing required input
            return HttpResponse("Missing required input", status=400)

        if not model:
            return HttpResponse("AI model not configured. Please check API key.", status=500)


        generated_docs_data = {}

        for doc_type in document_types:
            # Step 1: Refine the prompt generation logic
            # Create specific and detailed prompts for each document type
            base_prompt = f'''
            Anda adalah seorang ahli kurikulum merdeka yang membantu guru dalam menyusun dokumen pembelajaran.
            Berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan dari pengguna,
            buatlah dokumen {doc_type} dengan struktur yang jelas dan mendalam sesuai dengan kurikulum merdeka.

            Capaian Pembelajaran (CP):
            {cp_text}

            Data Tambahan:
            Mata Pelajaran: {subject}
            Kelas/Fase: {grade_phase}
            Tahun Ajaran: {academic_year}

            Instruksi spesifik untuk {doc_type}:
            '''

            # Add specific instructions based on document type
            if doc_type == 'Benah Capaian Pembelajaran':
                specific_instructions = '''
                Analisis CP di atas. Identifikasi elemen-elemen kunci dan kata kerja operasional.
                Sajikan kembali CP dalam bahasa yang lebih mudah dipahami atau diuraikan jika perlu (Benahan CP).
                Jelaskan implikasi CP ini untuk pembelajaran dan asesmen di kelas/fase ini.
                Format output: Bagian untuk "Capaian Pembelajaran Asli", "Benahan CP", dan "Implikasi Pembelajaran & Asesmen". Gunakan heading Markdown.
                '''
            elif doc_type == 'Tujuan Pembelajaran':
                specific_instructions = '''
                Uraikan CP di atas menjadi beberapa Tujuan Pembelajaran (TP).
                Setiap TP harus spesifik, terukur, dapat dicapai, relevan, dan berbasis waktu (SMART jika memungkinkan, atau setidaknya jelas komponennya).
                Sertakan elemen-elemen TP seperti Kompetensi, Konten, dan Variasi (sesuai kurikulum merdeka).
                Format output: Daftar TP bernomor atau berpoin dengan penjelasan singkat untuk setiap TP. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Alur Tujuan Pembelajaran':
                specific_instructions = '''
                Berdasarkan Tujuan Pembelajaran (TP) yang mungkin diimplikasikan dari CP (atau asumsikan TP yang relevan jika TP belum dibuat),
                susunlah Alur Tujuan Pembelajaran (ATP) yang logis dan berkesinambungan untuk satu fase atau satu tahun ajaran.
                Perkirakan alokasi waktu untuk setiap segmen ATP.
                Format output: Daftar ATP berurutan, jelaskan setiap langkah, dan sertakan perkiraan alokasi waktu. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Kriteria Ketuntasan Tujuan Pembelajaran':
                 specific_instructions = '''
                 Untuk setiap Tujuan Pembelajaran (TP) yang diimplikasikan dari CP, buatlah Kriteria Ketuntasan Tujuan Pembelajaran (KKTP).
                 KKTP harus jelas dan dapat diobservasi, menunjukkan bukti bahwa siswa telah mencapai tujuan pembelajaran.
                 Sertakan contoh bentuk asesmen yang dapat digunakan untuk mengukur KKTP tersebut.
                 Format output: Untuk setiap TP, sajikan KKTP dan contoh bentuk asesmen terkait. Gunakan heading, list, dan tabel sederhana Markdown.
                 '''
            elif doc_type == 'Program Semester':
                 specific_instructions = '''
                 Susunlah Program Semester (PROSEM) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam mingguan selama satu semester.
                 Sertakan topik/materi utama, kegiatan pembelajaran singkat, dan rencana asesmen untuk setiap minggu.
                 Format output: Tabel mingguan yang mencakup Minggu ke-, Topik/ATP, Kegiatan Singkat, dan Asesmen. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Program Tahunan':
                 specific_instructions = '''
                 Susunlah Program Tahunan (PROTA) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam bulanan atau per unit pembelajaran utama selama satu tahun ajaran.
                 Sertakan topik/materi utama dan perkiraan alokasi waktu untuk setiap unit/bulan.
                 Format output: Tabel bulanan/unit yang mencakup Bulan/Unit, Topik/ATP, dan Alokasi Waktu. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Modul Ajar':
                 specific_instructions = '''
                 Buatlah kerangka Modul Ajar lengkap untuk satu atau dua pertemuan berdasarkan Tujuan Pembelajaran (TP) dan Kriteria Ketuntasan Tujuan Pembelajaran (KKTP) yang diimplikasikan dari CP.
                 Sertakan komponen inti modul ajar seperti: Informasi Umum (identitas, kompetensi awal, profil pelajar pancasila, sarana prasarana, target peserta didik, model pembelajaran), Komponen Inti (tujuan pembelajaran, pemahaman bermakna, pertanyaan pemantik, kegiatan pembelajaran - pendahuluan, inti, penutup, asesmen - formatif/sumatif, pengayaan/remidial, refleksi guru/siswa), dan Lampiran (lembar kerja, bahan bacaan, glosarium, daftar pustaka).
                 Fokus pada bagian Komponen Inti dengan detail kegiatan pembelajaran.
                 Format output: Gunakan heading dan sub-heading Markdown untuk setiap bagian modul ajar.
                 '''
            else:
                # Default prompt if document type is not specifically handled
                specific_instructions = f'''
                Buatlah dokumen {doc_type} berdasarkan CP dan data tambahan di atas.
                Pastikan formatnya jelas dan relevan dengan konteks pembelajaran.
                Sajikan output dalam format Markdown.
                '''

            prompt = base_prompt + specific_instructions

            try:
                # Step 2: Implement the actual call to the configured Gemini AI model
                # Step 3: Extract the generated text content from the Gemini API response
                response = model.generate_content(prompt)
                generated_content = response.text # Extract text content

                # Step 4: Structure the extracted content
                # For now, we'll just store the text content.
                # If the prompt specifically asks for JSON or another format,
                # you would add parsing logic here. Markdown text is suitable for direct display.

                # Save the generated document to the database (conceptual)
                # document = Document(
                #     user=request.user,
                #     document_type=doc_type,
                #     input_data={
                #         'cp_text': cp_text,
                #         'subject': subject,
                #         'grade_phase': grade_phase,
                #         'academic_year': academic_year
                #         # Add other relevant input data here
                #     },
                #     generated_content=generated_content
                # )
                # document.save()
                # generated_docs_data[doc_type] = {'id': document.id, 'content': generated_content} # Store ID and content

                # For conceptual purposes, just store the content
                generated_docs_data[doc_type] = generated_content


            except Exception as e:
                # Handle API errors
                print(f"Error generating {doc_type}: {e}")
                generated_docs_data[doc_type] = f"Error generating document: {e}" # Indicate error in output


        # Redirect to a page showing the generated documents or a success message
        # Assuming a URL named 'document_list' exists
        # return redirect('document_list')
        # Or render a page showing the generated_docs_data content

        # For conceptual purposes, render a simple template showing generated content
        # You would need a template like 'generated_output.html'
        # return render(request, 'generated_output.html', {'generated_docs': generated_docs_data})

        # Returning a simple HttpResponse for demonstration
        output_html = "<h2>Generated Documents (Conceptual)</h2>"
        for doc_type, content in generated_docs_data.items():
            output_html += f"<h3>{doc_type}</h3>"
            output_html += f"<pre>{content}</pre>" # Use <pre> to preserve formatting
            output_html += "<hr>"

        return HttpResponse(output_html)


    # If not POST, maybe redirect or show an error
    return redirect('input_form') # Redirect back to the input form

"""**Reasoning**:
The previous command failed because Django settings were not configured in this environment. To proceed conceptually with the view logic, I will wrap the `genai.configure` and model initialization within the `generate_documents_view` function itself, or add a check, and also make the `settings.GEMINI_API_KEY` conceptual by using a placeholder or assuming it's available, to bypass the Django settings error and focus on the AI interaction logic. The core task is to implement the AI call and response handling.


"""

# In your Django app's views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
# from django.conf import settings # Import settings is not working conceptually here
import google.generativeai as genai
# from .models import Document # Assuming Document model exists

# Conceptually configure the generative AI model within the view or with a placeholder API key
# In a real application, configure this globally or more robustly.

@login_required
def generate_documents_view(request):
    # Conceptual API Key - REPLACE WITH SECURE LOADING IN REAL APP
    # Assuming the API key is available from a secure source like environment variables
    # In this conceptual code, we use a placeholder or assume it's accessible
    # Conceptual_GEMINI_API_KEY = "YOUR_CONCEPTUAL_GEMINI_API_KEY" # Replace with actual env var loading

    try:
        # Step 1: Refine the prompt generation logic (already done in previous attempt)
        # Step 2: Implement the actual call to the configured Gemini AI model
        # Configure the model within the view for this conceptual execution
        # In a real application, configure this globally or upon app start.
        # Using a placeholder/assuming API key is available
        genai.configure(api_key="YOUR_CONCEPTUAL_GEMINI_API_KEY") # Use placeholder to bypass config error conceptually
        model = genai.GenerativeModel('gemini-pro')
        # print("Gemini AI model configured successfully within view (conceptually).") # Avoid printing in view


    except Exception as e:
        print(f"Conceptual Error configuring Gemini AI model within view: {e}")
        return HttpResponse(f"AI model not configured conceptually. Error: {e}", status=500)

    if request.method == 'POST':
        cp_text = request.POST.get('cp_text', '')
        subject = request.POST.get('subject', '')
        grade_phase = request.POST.get('grade_phase', '')
        academic_year = request.POST.get('academic_year', '')
        document_types = request.POST.getlist('document_types') # Get list of selected types

        if not cp_text or not document_types:
            # Handle missing required input
            return HttpResponse("Missing required input", status=400)

        generated_docs_data = {}

        for doc_type in document_types:
            # Step 1: Refine the prompt generation logic
            # Create specific and detailed prompts for each document type
            base_prompt = f'''
            Anda adalah seorang ahli kurikulum merdeka yang membantu guru dalam menyusun dokumen pembelajaran.
            Berdasarkan Capaian Pembelajaran (CP) berikut dan data tambahan dari pengguna,
            buatlah dokumen {doc_type} dengan struktur yang jelas dan mendalam sesuai dengan kurikulum merdeka.

            Capaian Pembelajaran (CP):
            {cp_text}

            Data Tambahan:
            Mata Pelajaran: {subject}
            Kelas/Fase: {grade_phase}
            Tahun Ajaran: {academic_year}

            Instruksi spesifik untuk {doc_type}:
            '''

            # Add specific instructions based on document type
            if doc_type == 'Benah Capaian Pembelajaran':
                specific_instructions = '''
                Analisis CP di atas. Identifikasi elemen-elemen kunci dan kata kerja operasional.
                Sajikan kembali CP dalam bahasa yang lebih mudah dipahami atau diuraikan jika perlu (Benahan CP).
                Jelaskan implikasi CP ini untuk pembelajaran dan asesmen di kelas/fase ini.
                Format output: Bagian untuk "Capaian Pembelajaran Asli", "Benahan CP", dan "Implikasi Pembelajaran & Asesmen". Gunakan heading Markdown.
                '''
            elif doc_type == 'Tujuan Pembelajaran':
                specific_instructions = '''
                Uraikan CP di atas menjadi beberapa Tujuan Pembelajaran (TP).
                Setiap TP harus spesifik, terukur, dapat dicapai, relevan, dan berbasis waktu (SMART jika memungkinkan, atau setidaknya jelas komponennya).
                Sertakan elemen-elemen TP seperti Kompetensi, Konten, dan Variasi (sesuai kurikulum merdeka).
                Format output: Daftar TP bernomor atau berpoin dengan penjelasan singkat untuk setiap TP. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Alur Tujuan Pembelajaran':
                specific_instructions = '''
                Berdasarkan Tujuan Pembelajaran (TP) yang mungkin diimplikasikan dari CP (atau asumsikan TP yang relevan jika TP belum dibuat),
                susunlah Alur Tujuan Pembelajaran (ATP) yang logis dan berkesinambungan untuk satu fase atau satu tahun ajaran.
                Perkirakan alokasi waktu untuk setiap segmen ATP.
                Format output: Daftar ATP berurutan, jelaskan setiap langkah, dan sertakan perkiraan alokasi waktu. Gunakan heading dan list Markdown.
                '''
            elif doc_type == 'Kriteria Ketuntasan Tujuan Pembelajaran':
                 specific_instructions = '''
                 Untuk setiap Tujuan Pembelajaran (TP) yang diimplikasikan dari CP, buatlah Kriteria Ketuntasan Tujuan Pembelajaran (KKTP).
                 KKTP harus jelas dan dapat diobservasi, menunjukkan bukti bahwa siswa telah mencapai tujuan pembelajaran.
                 Sertakan contoh bentuk asesmen yang dapat digunakan untuk mengukur KKTP tersebut.
                 Format output: Untuk setiap TP, sajikan KKTP dan contoh bentuk asesmen terkait. Gunakan heading, list, dan tabel sederhana Markdown.
                 '''
            elif doc_type == 'Program Semester':
                 specific_instructions = '''
                 Susunlah Program Semester (PROSEM) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam mingguan selama satu semester.
                 Sertakan topik/materi utama, kegiatan pembelajaran singkat, dan rencana asesmen untuk setiap minggu.
                 Format output: Tabel mingguan yang mencakup Minggu ke-, Topik/ATP, Kegiatan Singkat, dan Asesmen. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Program Tahunan':
                 specific_instructions = '''
                 Susunlah Program Tahunan (PROTA) berdasarkan Alur Tujuan Pembelajaran (ATP) yang diimplikasikan dari CP.
                 Bagi ATP tersebut ke dalam bulanan atau per unit pembelajaran utama selama satu tahun ajaran.
                 Sertakan topik/materi utama dan perkiraan alokasi waktu untuk setiap unit/bulan.
                 Format output: Tabel bulanan/unit yang mencakup Bulan/Unit, Topik/ATP, dan Alokasi Waktu. Gunakan tabel Markdown.
                 '''
            elif doc_type == 'Modul Ajar':
                 specific_instructions = '''
                 Buatlah kerangka Modul Ajar lengkap untuk satu atau dua pertemuan berdasarkan Tujuan Pembelajaran (TP) dan Kriteria Ketuntasan Tujuan Pembelajaran (KKTP) yang diimplikasikan dari CP.
                 Sertakan komponen inti modul ajar seperti: Informasi Umum (identitas, kompetensi awal, profil pelajar pancasila, sarana prasarana, target peserta didik, model pembelajaran), Komponen Inti (tujuan pembelajaran, pemahaman bermakna, pertanyaan pemantik, kegiatan pembelajaran - pendahuluan, inti, penutup, asesmen - formatif/sumatif, pengayaan/remidial, refleksi guru/siswa), dan Lampiran (lembar kerja, bahan bacaan, glosarium, daftar pustaka).
                 Fokus pada bagian Komponen Inti dengan detail kegiatan pembelajaran.
                 Format output: Gunakan heading dan sub-heading Markdown untuk setiap bagian modul ajar.
                 '''
            else:
                # Default prompt if document type is not specifically handled
                specific_instructions = f'''
                Buatlah dokumen {doc_type} berdasarkan CP dan data tambahan di atas.
                Pastikan formatnya jelas dan relevan dengan konteks pembelajaran.
                Sajikan output dalam format Markdown.
                '''

            prompt = base_prompt + specific_instructions

            try:
                # Step 2: Implement the actual call to the configured Gemini AI model
                response = model.generate_content(prompt)
                # Step 3: Extract the generated text content from the Gemini API response
                generated_content = response.text # Extract text content

                # Step 4: Structure the extracted content
                # For now, we'll just store the text content.
                # If the prompt specifically asks for JSON or another format,
                # you would add parsing logic here. Markdown text is suitable for direct display.

                # Save the generated document to the database (conceptual)
                # document = Document(
                #     user=request.user,
                #     document_type=doc_type,
                #     input_data={
                #         'cp_text': cp_text,
                #         'subject': subject,
                #         'grade_phase': grade_phase,
                #         'academic_year': academic_year
                #         # Add other relevant input data here
                #     },
                #     generated_content=generated_content
                # )
                # document.save()
                # generated_docs_data[doc_type] = {'id': document.id, 'content': generated_content} # Store ID and content

                # For conceptual purposes, just store the content
                generated_docs_data[doc_type] = generated_content


            except Exception as e:
                # Handle API errors
                print(f"Error generating {doc_type}: {e}")
                generated_docs_data[doc_type] = f"Error generating document: {e}" # Indicate error in output


        # Redirect to a page showing the generated documents or a success message
        # Assuming a URL named 'document_list' exists
        # return redirect('document_list')
        # Or render a page showing the generated_docs_data content

        # For conceptual purposes, render a simple template showing generated content
        # You would need a template like 'generated_output.html'
        # return render(request, 'generated_output.html', {'generated_docs': generated_docs_data})

        # Returning a simple HttpResponse for demonstration
        output_html = "<h2>Generated Documents (Conceptual)</h2>"
        if generated_docs_data:
            for doc_type, content in generated_docs_data.items():
                output_html += f"<h3>{doc_type}</h3>"
                output_html += f"<pre>{content}</pre>" # Use <pre> to preserve formatting
                output_html += "<hr>"
        else:
             output_html += "<p>No documents were generated.</p>"


        return HttpResponse(output_html)


    # If not POST, maybe redirect or show an error
    return redirect('input_form') # Redirect back to the input form

"""## Penyimpanan data

### Subtask:
Menyimpan data pengguna dan dokumen yang dihasilkan di basis data terkait dengan akun Google mereka.

**Reasoning**:
Define the Django models for User and Document, including the necessary fields and relationships, and then conceptually run migrations.
"""

# In your Django app's models.py

from django.db import models
from django.contrib.auth.models import User # Django's built-in User model
from allauth.socialaccount.models import SocialAccount # Import SocialAccount

# Step 1: Define Django models

# We can leverage the built-in Django User model.
# allauth automatically links SocialAccount to the built-in User.
# No need to define a custom User model unless we need extra profile fields
# beyond what SocialAccount provides (e.g., Google ID, email are in SocialAccount).

# Define the Document model
class Document(models.Model):
    """
    Model to store generated learning documents.
    """
    # Link to the User model
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='documents')

    document_type = models.CharField(max_length=255) # e.g., 'Tujuan Pembelajaran', 'Modul Ajar'

    # Store user input data - using JSONField is flexible
    # Requires PostgreSQL or a library like django-jsonfield for other databases
    # Or use a TextField and store data as JSON string
    input_data = models.JSONField(default=dict)

    # Store the generated content from Gemini AI
    generated_content = models.TextField()

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.document_type} for {self.user.email} ({self.created_at.strftime('%Y-%m-%d')})"

    class Meta:
        ordering = ['-created_at'] # Order by most recent first

# Conceptual steps to apply migrations
print("--- Conceptual Django Model Definitions ---")
print("Defined Document model linked to the built-in User model.")
print("--- Conceptual Migration Steps ---")
print("""
In a real Django project, after defining or modifying models, you would run:

python manage.py makemigrations
python manage.py migrate

These commands create database tables based on your model definitions.
""")

"""**Reasoning**:
The previous attempt failed because Django settings are not configured in this environment, preventing model definition. Since actual model definition and migration execution are not possible, I will describe the conceptual model definitions again and reiterate the migration steps, acknowledging the environment limitation.


"""

# Step 1: Describe Django models conceptually again, fixing syntax

print("--- Conceptual Django Model Definitions (Reiterated and Fixed) ---")
print("""
In a real Django project, you would define your models in a file like `your_app/models.py`.

We will use the built-in Django `User` model, which `django-allauth` integrates with to handle Google accounts via the `SocialAccount` model.

We need a `Document` model to store the generated content. It should be linked to the `User` model.

"""**Reasoning**:
The previous attempt failed due to a `SyntaxError` in the triple-quoted string. I will fix the syntax error and print the conceptual model definitions and migration steps again.


"""

# Step 1: Describe Django models conceptually again, fixing syntax

print("--- Conceptual Django Model Definitions (Reiterated and Fixed) ---")
print("""
In a real Django project, you would define your models in a file like `your_app/models.py`.

We will use the built-in Django `User` model, which `django-allauth` integrates with to handle Google accounts via the `SocialAccount` model.

We need a `Document` model to store the generated content. It should be linked to the `User` model.

```python
from django.db import models
from django.contrib.auth.models import User # Django's built-in User model
# from allauth.socialaccount.models import SocialAccount # Import SocialAccount if needed directly in models

class Document(models.Model):
    """
    Model to store generated learning documents.
    """
    # Link to the User model - CASCADE ensures documents are deleted if the user is deleted
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='documents')

    # Type of the document (e.g., 'Tujuan Pembelajaran', 'Modul Ajar')
    document_type = models.CharField(max_length=255)

    # Store user input data as a JSON object for flexibility
    # Use JSONField if your database supports it (like PostgreSQL)
    # Otherwise, use TextField and store data as a JSON string (requires manual serialization/deserialization)
    input_data = models.JSONField(default=dict) # Or models.TextField() for JSON string

    # Store the generated content from Gemini AI
    generated_content = models.TextField()

    # Timestamps for tracking creation and updates
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.document_type} for {self.user.email} ({self.created_at.strftime('%Y-%m-%d')})"

    class Meta:
        ordering = ['-created_at'] # Default ordering: most recent first
```

This conceptual code defines the structure needed for the `Document` model and its relationship with the `User` model.

--- Conceptual Migration Steps (Reiterated and Fixed) ---
""")
print("""
Because we cannot execute Django management commands in this environment, we conceptually outline the steps to create the database tables for these models:

1.  **Add your app to `INSTALLED_APPS`:** Ensure the Django app containing your `models.py` file is listed in the `INSTALLED_APPS` setting in your project's `settings.py`.
2.  **Run `makemigrations`:** Open your terminal, navigate to your Django project's root directory (where `manage.py` is located), and run:
    ```bash
    python manage.py makemigrations your_app_name
    ```
    (Replace `your_app_name` with the actual name of your Django app). This command creates migration files that represent the changes to your models.
3.  **Run `migrate`:** In the same terminal, run:
    ```bash
    python manage.py migrate
    ```
    This command applies the pending migrations to your database, creating the necessary tables (including `auth_user`, `socialaccount_socialaccount`, and your new `your_app_name_document` table).

These steps are essential to set up the database schema required to store user documents.
""")

"""**Reasoning**:
The `SyntaxError` persists, likely due to how the interpreter handles triple-quoted strings in this environment. I will try a different approach to print the conceptual code and instructions, avoiding complex multi-line strings within the `print` function call itself. I will then describe the process of modifying the `generate_documents_view` to save the document objects.


"""

# Step 1: Describe Django models conceptually using simpler prints
print("--- Conceptual Django Model Definitions (Attempt 3) ---")
print("In a real Django project, you would define your models in a file like `your_app/models.py`.")
print("")
print("We will use the built-in Django `User` model, which `django-allauth` integrates with.")
print("We need a `Document` model to store the generated content, linked to the `User`.")
print("")
print("```python")
print("from django.db import models")
print("from django.contrib.auth.models import User")
print("")
print("class Document(models.Model):")
print("    \"\"\"Model to store generated learning documents.\"\"\"")
print("    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='documents')")
print("    document_type = models.CharField(max_length=255)")
print("    input_data = models.JSONField(default=dict)")
print("    generated_content = models.TextField()")
print("    created_at = models.DateTimeField(auto_now_add=True)")
print("    updated_at = models.DateTimeField(auto_now=True)")
print("")
print("    def __str__(self):")
print("        return f\"{self.document_type} for {self.user.email} ({self.created_at.strftime('%Y-%m-%d')})\"")
print("")
print("    class Meta:")
print("        ordering = ['-created_at']")
print("```")
print("")
print("This conceptual code defines the structure needed for the `Document` model.")
print("")
print("--- Conceptual Migration Steps (Attempt 3) ---")
print("Because we cannot execute Django management commands in this environment, we conceptually outline the steps:")
print("")
print("1. Add your app to `INSTALLED_APPS` in `settings.py`.")
print("2. Run `python manage.py makemigrations your_app_name` in your terminal.")
print("3. Run `python manage.py migrate` in your terminal.")
print("")
print("These steps are essential to set up the database schema.")

# Step 2-5: Describe modifying the generate_documents_view to save documents and redirect
print("\n--- Conceptual Modifications to generate_documents_view ---")
print(""
In your Django app's `views.py` file, you need to modify the `generate_documents_view` function.

After you successfully get the `generated_content` from the Gemini API for each `doc_type`, you will create a `Document` object and save it.

Here's the conceptual code snippet to add within the `for doc_type in document_types:` loop, after `generated_content` is obtained:

```python
# Assuming 'generated_content' contains the AI-generated text for the current doc_type

# Create a new Document object
document = Document(
    user=request.user, # The currently logged-in user
    document_type=doc_type,
    input_data={
        'cp_text': cp_text,
        'subject': subject,
        'grade_phase': grade_phase,
        'academic_year': academic_year
        # Add any other relevant input data here that you want to store
    },
    generated_content=generated_content
)

# Save the document to the database
document.save()

# Optional: Store document ID if needed later, though redirecting to list is common
# generated_docs_data[doc_type] = document.id # Store the ID if needed
```

After the loop finishes (meaning all selected documents have been generated and saved), you should redirect the user to the document list page. Replace the current return statement with a redirect:

```python
# After the for loop finishes:
from django.shortcuts import redirect

# Assuming a URL named 'document_list' exists in your urls.py
return redirect('document_list')

# Make sure to import 'redirect' at the top of your views.py
```

This modification ensures that each generated document is persistently stored in the database and the user is directed to a page where they can view their saved documents.
"")

"""**Reasoning**:
The previous attempt still resulted in a `SyntaxError` with the multi-line string. I will break down the printing of the conceptual view modifications into smaller, simpler print statements to avoid the string literal issue. This will fulfill steps 2-5 of the subtask conceptually.


"""

# Step 2-5: Describe modifying the generate_documents_view to save documents and redirect using simpler prints

print("--- Conceptual Modifications to generate_documents_view (Attempt 2) ---")
print("In your Django app's `views.py` file, you need to modify the `generate_documents_view` function.")
print("")
print("After you successfully get the `generated_content` from the Gemini API for each `doc_type`,")
print("you will create a `Document` object and save it.")
print("")
print("Here's the conceptual code snippet to add within the `for doc_type in document_types:` loop,")
print("after `generated_content` is obtained:")
print("")
print("```python")
print("# Assuming 'generated_content' contains the AI-generated text for the current doc_type")
print("")
print("# Create a new Document object")
print("document = Document(")
print("    user=request.user, # The currently logged-in user")
print("    document_type=doc_type,")
print("    input_data={")
print("        'cp_text': cp_text,")
print("        'subject': subject,")
print("        'grade_phase': grade_phase,")
print("        'academic_year': academic_year")
print("        # Add any other relevant input data here that you want to store")
print("    },")
print("    generated_content=generated_content")
print(")")
print("")
print("# Save the document to the database")
print("document.save()")
print("")
print("# Optional: Store document ID if needed later, though redirecting to list is common")
print("# generated_docs_data[doc_type] = document.id # Store the ID if needed")
print("```")
print("")
print("After the loop finishes (meaning all selected documents have been generated and saved),")
print("you should redirect the user to the document list page.")
print("Replace the current return statement with a redirect:")
print("")
print("```python")
print("# After the for loop finishes:")
print("from django.shortcuts import redirect # Make sure to import 'redirect' at the top")
print("")
print("# Assuming a URL named 'document_list' exists in your urls.py")
print("return redirect('document_list')")
print("```")
print("")
print("This modification ensures that each generated document is persistently stored in the database")
print("and the user is directed to a page where they can view their saved documents.")

"""## Pengujian

### Subtask:
Melakukan pengujian menyeluruh untuk memastikan semua fitur berfungsi dengan baik, termasuk login, input data, generasi dokumen, dan penyimpanan.

**Reasoning**:
Outline the conceptual test plan, including test cases for each feature and their expected outcomes.
"""

# Step 1: Write a conceptual test plan
# Step 2: Describe the expected outcome for each test case

print("--- Conceptual Test Plan ---")

print("\n## 1. Login Feature Tests")
print("### Test Cases:")
print("- **Test Case 1.1:** Successful Google Login")
print("  - **Description:** User clicks 'Sign in with Google' and completes the Google authentication flow.")
print("  - **Expected Outcome:** User is successfully authenticated and redirected to the document input page (or `LOGIN_REDIRECT_URL`). A new user or social account is created/linked in the database.")

print("- **Test Case 1.2:** Login with Existing Google Account")
print("  - **Description:** User who previously logged in with Google attempts to log in again.")
print("  - **Expected Outcome:** User is successfully authenticated and redirected. The existing user and social account are used; no new ones are created.")

print("- **Test Case 1.3:** Login Failure (e.g., Google error, user cancels)")
print("  - **Description:** User attempts Google login but the process fails or is cancelled on the Google side.")
print("  - **Expected Outcome:** User is returned to the login page with an appropriate error message (handled by `django-allauth`).")

print("- **Test Case 1.4:** Accessing Protected Page Before Login")
print("  - **Description:** Anonymous user attempts to access a page requiring authentication (e.g., input form, document list) directly via URL.")
print("  - **Expected Outcome:** User is redirected to the login page (`ACCOUNT_LOGOUT_REDIRECT_URL` or similar setting).")


print("\n## 2. Data Input Feature Tests")
print("### Test Cases:")
print("- **Test Case 2.1:** Successful Data Submission")
print("  - **Description:** Logged-in user fills in all required fields on the input form (CP text, subject, grade/phase, academic year) and selects at least one document type, then submits.")
print("  - **Expected Outcome:** The form submission is successful (HTTP 200 or 302 redirect). The backend receives the input data and initiated the document generation process. User is redirected to the document list or a confirmation page.")

print("- **Test Case 2.2:** Missing Required Fields")
print("  - **Description:** Logged-in user attempts to submit the input form with one or more required fields left blank (e.g., empty CP text, no document types selected).")
print("  - **Expected Outcome:** The server returns an error (e.g., HTTP 400) or the form displays validation errors, preventing submission or indicating missing fields.")

print("- **Test Case 2.3:** Invalid Data Format (if applicable, e.g., non-numeric year)")
print("  - **Description:** User enters data in an unexpected format (e.g., text in a field expecting a year, although current fields are flexible).")
print("  - **Expected Outcome:** Depending on backend validation, the server returns an error or validation fails. (Less critical for current text-based fields).")


print("\n## 3. Document Generation Feature Tests")
print("### Test Cases:")
print("- **Test Case 3.1:** Generation of Single Document Type")
print("  - **Description:** User inputs data and selects only one document type (e.g., 'Tujuan Pembelajaran').")
print("  - **Expected Outcome:** The backend successfully calls the Gemini AI API with a prompt specific to 'Tujuan Pembelajaran'. The API returns content, which is processed and conceptually saved.")

print("- **Test Case 3.2:** Generation of Multiple Document Types")
print("  - **Description:** User inputs data and selects multiple document types (e.g., 'Tujuan Pembelajaran', 'Alur Tujuan Pembelajaran').")
print("  - **Expected Outcome:** The backend successfully calls the Gemini AI API for *each* selected document type with appropriate prompts. API returns content for each, which is processed and conceptually saved.")

print("- **Test Case 3.3:** Gemini AI API Error Handling")
print("  - **Description:** The Gemini AI API returns an error during the generation process (e.g., rate limit exceeded, invalid request).")
print("  - **Expected Outcome:** The backend catches the API error. An appropriate error message is displayed to the user or logged, and the process for that document type might fail gracefully.")

print("- **Test Case 3.4:** Content Relevance and Structure (Manual/Qualitative Test)")
print("  - **Description:** Review the generated document content for accuracy, relevance to the input CP, and adherence to the requested structure (e.g., Markdown headings, lists, tables).")
print("  - **Expected Outcome:** The generated content is largely relevant to the input and follows the structural instructions given in the prompt.")


print("\n## 4. Data Storage Feature Tests")
print("### Test Cases:")
print("- **Test Case 4.1:** Document Saved to Database After Generation")
print("  - **Description:** After successful document generation, check the database.")
print("  - **Expected Outcome:** A new record exists in the `Documents` table for each successfully generated document type. Each record is linked to the logged-in user, contains the correct document type, the input data, and the generated content.")

print("- **Test Case 4.2:** Input Data Stored Correctly")
print("  - **Description:** Examine the `input_data` field in the saved document record.")
print("  - **Expected Outcome:** The `input_data` field (e.g., JSON or text) accurately reflects the data submitted by the user (CP text, subject, etc.).")

print("- **Test Case 4.3:** Generated Content Stored Correctly")
print("  - **Description:** Examine the `generated_content` field in the saved document record.")
print("  - **Expected Outcome:** The `generated_content` field contains the exact text received from the Gemini AI API for that document type.")

print("- **Test Case 4.4:** Document Linked to Correct User")
print("  - **Description:** Examine the `user_id` field in the saved document record.")
print("  - **Expected Outcome:** The `user_id` field correctly references the primary key of the logged-in user in the `Users` table.")


print("\n## 5. Document Display Feature Tests")
print("### Test Cases:")
print("- **Test Case 5.1:** List of User's Documents Displayed")
print("  - **Description:** Logged-in user navigates to the document list page.")
print("  - **Expected Outcome:** The page displays a list of all documents previously generated and saved for this user, showing document type and potentially creation date.")

print("- **Test Case 5.2:** Viewing a Specific Document")
print("  - **Description:** User clicks on a document in the list.")
print("  - **Expected Outcome:** The content of the selected document is displayed. The displayed content matches the `generated_content` stored in the database for that document.")

print("- **Test Case 5.3:** Document Content Formatting")
print("  - **Description:** View the displayed document content, especially if it uses Markdown.")
print("  - **Expected Outcome:** The Markdown formatting (headings, lists, tables) is rendered correctly in the web browser.")

print("- **Test Case 5.4:** Accessing Another User's Document (Security Test)")
print("  - **Description:** Attempt to access a document belonging to a different user by manipulating the URL (e.g., changing the document ID).")
print("  - **Expected Outcome:** The server prevents access and returns an error (e.g., HTTP 404 Not Found or HTTP 403 Forbidden), as the document is not owned by the currently logged-in user.")

"""**Reasoning**:
Describe how to perform the outlined tests in a real Django development environment using appropriate testing methods.


"""

# Step 3: Explain how to perform these tests in a real Django development environment

print("--- How to Perform These Tests in a Real Django Environment ---")

print("\nTesting a web application involves a combination of automated and manual testing.")

print("\n## 1. Automated Testing (Using Django Test Client)")
print("Django's built-in `django.test.Client` and `TestCase` class are excellent for testing backend logic, views, and forms without needing a browser.")

print("### Setup:")
print("- Create a `tests.py` file in your Django app.")
print("- Import `TestCase` from `django.test` and `reverse` from `django.urls`.")
print("- Import your views, models, and forms.")
print("- You'll need to mock external services like the Google Auth process and the Gemini AI API for reliable automated tests.")

print("### Examples for Automated Tests:")

print("\n#### 1. Login Tests (Conceptual Mocking)")
print("""

"""## Deployment

### Subtask:
Menerapkan website ke server web.

**Reasoning**:
The current subtask is to deploy the website to a web server. This involves several steps from choosing a platform to testing the deployed application. Since I cannot perform actual deployment steps in this environment, I will outline the conceptual steps and considerations for deployment, covering the instructions sequentially. I will start by describing the platform selection and database setup, as these are foundational steps.
"""

# Step 1: Choose platform and Step 2: Set up database server (Conceptual)

print("--- Conceptual Deployment: Platform Selection and Database Setup ---")

print("\n## 1. Platform Selection Considerations:")
print("Choosing a deployment platform depends on various factors:")
print("- **Cost:** Free tiers vs. paid plans, scaling costs.")
print("- **Ease of Use:** Simplicity of setup, deployment process, dashboard.")
print("- **Scalability:** Ability to handle increased traffic and data over time.")
print("- **Integration:** How well it integrates with databases, storage, and other services.")
print("- **Framework Support:** Good support for Python/Django applications.")
print("\nCommon platforms suitable for Django applications include:")
print("- **Heroku:** Known for ease of use ('git push heroku main'). Offers a free tier (with limitations), managed PostgreSQL database.")
print("- **AWS Elastic Beanstalk:** More powerful and flexible, integrates deeply with other AWS services. Requires more configuration.")
print("- **Google Cloud Platform (GCP) App Engine or Cloud Run:** Serverless or managed options, integrates with GCP services like Cloud SQL (PostgreSQL/MySQL).")
print("- **PythonAnywhere:** Simple hosting specifically for Python web apps, good for smaller projects or beginners.")

print("\nFor this conceptual deployment, let's consider **Heroku** as a straightforward option, although the principles apply to others.")

print("\n## 2. Database Server Setup (Conceptual):")
print("Regardless of the platform, you'll need a production-ready database.")
print("For Django, PostgreSQL is a common and robust choice.")

print("\n### Conceptual Steps for Database Setup (using Heroku PostgreSQL as an example):")
print("1.  **Provision a Database:** On Heroku, you would add the Heroku Postgres add-on to your application.")
print("    ```bash")
print("    heroku addons:create heroku-postgresql:hobby-dev -a your-heroku-app-name")
print("    ```")
print("    *(This is a conceptual command line example)*")
print("2.  **Obtain Database Credentials:** The platform provides the database URL (including hostname, database name, user, password, port). On Heroku, this is typically available in a `DATABASE_URL` environment variable.")
print("3.  **Configure Django Database Settings:** In your Django `settings.py`, you'll need to configure the `DATABASES` setting to use the production database URL.")
print("    - Install a library like `dj-database-url` to easily parse the `DATABASE_URL` environment variable.")
print("      ```bash")
print("      pip install dj-database-url gunicorn psycopg2-binary whitenoise")
print("      ```")
print("      *(Conceptual installation)*")
print("    - In `settings.py`, use `dj_database_url.config()`:")
print("      ```python")
print("      # settings.py")
print("      import dj_database_url")
print("      import os")

print("      # Use the DATABASE_URL environment variable provided by the platform")
print("      DATABASES = {")
print("          'default': dj_database_url.config(conn_max_age=600)")
print("      }")
print("      # Ensure DATABASE_URL is set in your production environment variables")
print("      # e.g., heroku config:set DATABASE_URL='postgres://user:password@host:port/dbname'")
print("      # Or if using .env for local testing of prod settings:")
print("      # load_dotenv()")
print("      # DATABASES['default'] = dj_database_url.config(default=os.environ.get('DATABASE_URL'))")
print("      ```")
print("4.  **Ensure Psycopg2 is Installed:** Django needs a database adapter. For PostgreSQL, `psycopg2-binary` is commonly used.")
print("    *(Already included in the conceptual pip install above)*")


print("\nConceptual steps for platform selection and database setup have been outlined.")
print("Next, I will describe configuring production settings and setting up the web server.")

"""**Reasoning**:
Continue outlining the conceptual deployment steps by describing how to configure Django's production settings and set up the web server (WSGI server like Gunicorn). This covers steps 3 and 4 of the instructions.


"""

# Step 3: Configure production settings (Conceptual)
# Step 4: Set up web server (Conceptual)

print("--- Conceptual Deployment: Production Settings and Web Server Setup ---")

print("\n## 3. Configure Production Settings (Conceptual):")
print("Django's settings need to be adjusted for a production environment for security, performance, and proper serving of static files.")

print("\n### Conceptual `settings.py` adjustments for production:")
print("```python")
print("# settings.py")
print("import os")
print("# Assuming dj_database_url is already imported and used for DATABASES")
print("# Assuming dotenv is imported and used for loading environment variables locally")

print("# SECURITY WARNING: don't run with debug turned on in production!")
print("DEBUG = os.environ.get('DJANGO_DEBUG', 'False') == 'True'")

print("# SECURITY WARNING: keep the secret key used in production secret!")
print("SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY') # Load from environment variable")
print("# Ensure DJANGO_SECRET_KEY is set in your production environment variables")

print("# Add your production domain names and potentially the platform's domain")
print("ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS', '').split(',')")
print("# Ensure DJANGO_ALLOWED_HOSTS is set in your production environment variables, e.g., 'your-app-name.herokuapp.com,your-custom-domain.com'")

print("# Static files (CSS, JavaScript, Images)")
print("# https://docs.djangoproject.com/en/stable/howto/static-files/")

print("STATIC_URL = '/static/'")
print("STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') # Directory where static files are collected")

print("# Configure WhiteNoise to serve static files")
print("STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'")

print("# Where Django looks for additional static files (e.g., in app's static directories)")
print("STATICFILES_DIRS = [")
print("    os.path.join(BASE_DIR, 'static'),")
print("]")

print("# Media files (User uploads) - Requires separate configuration, often cloud storage like S3")
print("MEDIA_URL = '/media/'")
print("MEDIA_ROOT = os.path.join(BASE_DIR, 'media')")
print("# For production, consider using cloud storage like AWS S3 or Google Cloud Storage")

print("# Logging configuration (Important for production)")
print("# Configure logging to output errors and important information")
print("# Example basic logging:")
print("LOGGING = {")
print("    'version': 1,")
print("    'disable_existing_loggers': False,")
print("    'handlers': {")
print("        'console': {")
print("            'class': 'logging.StreamHandler',")
print("        },")
print("    },")
print("    'root': {")
print("        'handlers': ['console'],")
print("        'level': 'INFO',")
print("    },")
print("}")

print("# Ensure API keys and secrets are loaded from environment variables")
print("# GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID')")
print("# GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET')")
print("# GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')")
print("# Ensure these are set securely in the production environment")


print("```")
print("\n## 4. Set up Web Server and WSGI Server (Conceptual):")
print("In production, you don't use Django's development server (`runserver`). You need a dedicated web server and a WSGI (Web Server Gateway Interface) server.")

print("\n### Conceptual Setup:")
print("1.  **Install a WSGI server:** Gunicorn is a popular choice for Python.")
print("    *(Already included in the conceptual pip install in the previous step)*")
print("2.  **Create a `Procfile` (for Heroku):** This file tells Heroku how to run your application.")
print("    ```")
print("    # Procfile")
print("    web: gunicorn your_project.wsgi --log-file -")
print("    ```")
print("    *(Replace `your_project` with your actual Django project name)*")
print("    - `web`: Specifies a web process.")
print("    - `gunicorn your_project.wsgi`: Runs the Gunicorn server, pointing to your project's WSGI module.")
print("    - `--log-file -`: Directs logs to standard output, which Heroku captures.")
print("3.  **Configure WSGI File:** Ensure your `your_project/wsgi.py` file is correctly configured to serve your application.")
print("    - It typically imports `get_wsgi_application` and sets the `DJANGO_SETTINGS_MODULE` environment variable.")
print("    - For production, you might need to explicitly set `DJANGO_SETTINGS_MODULE` to your production settings file if you use a different one, though often you just use environment variables to control settings within the main `settings.py`.")
print("    ```python")
print("    # your_project/wsgi.py")
print("    import os")
print("    from django.core.wsgi import get_wsgi_application")

print("    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'your_project.settings') # Points to your settings file")

print("    application = get_wsgi_application()")

print("    # Optional: Wrap with WhiteNoise for static files (if not using a separate static file server)")
print("    # from whitenoise.django import DjangoWhiteNoise")
print("    # application = DjangoWhiteNoise(application)")
print("    ```")
print("4.  **Use WhiteNoise for Static Files (Simple Approach):** For simpler deployments like on Heroku, WhiteNoise is a good option to serve static files directly from Django.")
print("    - Install `whitenoise`.")
print("      *(Already included in the conceptual pip install)*")
print("    - Configure `STATICFILES_STORAGE` in `settings.py` (as shown above).")
print("    - Add `whitenoise.middleware.WhiteNoiseMiddleware` to your `MIDDLEWARE` in `settings.py` (usually near the top, after `SecurityMiddleware`).")
print("    ```python")
print("    # settings.py")
print("    MIDDLEWARE = [")
print("        # ... other middleware")
print("        'django.middleware.security.SecurityMiddleware',")
print("        'whitenoise.middleware.WhiteNoiseMiddleware', # Add this line")
print("        # ... other middleware")
print("    ]")
print("    ```")


print("\nConceptual steps for configuring production settings and setting up the web server have been outlined.")
print("Next, I will describe setting up static file serving and deploying the code.")

"""**Reasoning**:
Continue outlining the conceptual deployment steps by describing how to set up static file serving (which was partially covered but needs more detail on collection), deploy the code to the chosen platform, and run database migrations. This covers steps 5, 6, and 7 of the instructions.


"""

# Step 5: Set up static file server (Conceptual, partially covered by WhiteNoise)
# Step 6: Deploy code (Conceptual)
# Step 7: Run database migrations (Conceptual)

print("--- Conceptual Deployment: Static Files, Code Deployment, and Migrations ---")

print("\n## 5. Set up Static File Serving (Conceptual):")
print("Serving static files (CSS, JS, images) efficiently is crucial in production.")
print("While WhiteNoise is configured in settings.py for a simple approach, you still need to collect static files.")
print("\n### Conceptual Steps for Static File Serving:")
print("1.  **Collect Static Files:** Before deploying, you need to gather all static files from your apps and project into the `STATIC_ROOT` directory.")
print("    ```bash")
print("    python manage.py collectstatic")
print("    ```")
print("    *(This command is run locally before deployment, or as part of the build process on platforms like Heroku)*")
print("2.  **WhiteNoise Configuration:** Ensure `whitenoise.middleware.WhiteNoiseMiddleware` is in your `MIDDLEWARE` and `STATICFILES_STORAGE` is set in `settings.py` (as described in the previous step). WhiteNoise will then serve the files collected in `STATIC_ROOT`.")
print("3.  **Alternative (Cloud Storage):** For larger applications or more robust solutions, you might use cloud storage like AWS S3 or Google Cloud Storage for static and media files. This requires additional configuration (e.g., using `django-storages`) and setting up credentials.")
print("    *(For this conceptual outline, we stick with the simpler WhiteNoise approach)*")

print("\n## 6. Deploy Code (Conceptual):")
print("The process for deploying your code varies significantly by platform.")

print("\n### Conceptual Steps for Deploying Code (using Heroku as an example):")
print("1.  **Initialize Git Repository:** Ensure your project is under Git version control.")
print("2.  **Create Heroku Application:** Create a new application on Heroku.")
print("    ```bash")
print("    heroku create your-heroku-app-name")
print("    ```")
print("    *(Conceptual command)*")
print("3.  **Add Heroku Git Remote:** Add the Heroku application as a Git remote.")
print("    ```bash")
print("    heroku git:remote -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command)*")
print("4.  **Prepare for Deployment:** Ensure you have a `requirements.txt` file listing all Python dependencies (`pip freeze > requirements.txt`) and the `Procfile` is correctly configured.")
print("5.  **Push to Heroku:** Deploy your code by pushing to the Heroku remote.")
print("    ```bash")
print("    git push heroku main")
print("    ```")
print("    *(Conceptual command)*")
print("    - Heroku will detect the Python app, install dependencies from `requirements.txt`, run `collectstatic`, and start the web process defined in the `Procfile`.")

print("\n### Conceptual Steps for Deploying Code (General):")
print("- Other platforms might involve building a Docker image, using platform-specific deployment tools, or uploading code via SFTP.")
print("- The key is getting your codebase onto the server environment.")

print("\n## 7. Run Database Migrations (Conceptual):")
print("After deploying your code and setting up the database, you need to apply any database schema changes (migrations).")

print("\n### Conceptual Steps for Running Migrations:")
print("1.  **Run Migrations:** Execute the `migrate` command on the production server.")
print("    ```bash")
print("    heroku run python manage.py migrate -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command for Heroku)*")
print("    - This command connects to the production database using the `DATABASE_URL` environment variable and applies any pending migrations defined in your Django app's `migrations` directories.")
print("2.  **Create Superuser (if needed):** You might need to create an admin user on the production database.")
print("    ```bash")
print("    heroku run python manage.py createsuperuser -a your-heroku-app-name")
print("    ```")
print("    *(Conceptual command for Heroku)*")

print("\nConceptual steps for setting up static files, deploying code, and running database migrations have been outlined.")
print("Next, I will describe configuring environment variables and testing the deployed application.")

"""**Reasoning**:
The final steps of the deployment process involve configuring environment variables on the production platform and thoroughly testing the deployed application. I will outline these steps conceptually, covering instructions 8 and 9.


"""

# Step 8: Configure environment variables (Conceptual)
# Step 9: Test the deployed application (Conceptual)

print("--- Conceptual Deployment: Environment Variables and Testing ---")

print("\n## 8. Configure Environment Variables (Conceptual):")
print("Sensitive information like `SECRET_KEY`, API keys, and database credentials should not be hardcoded. They must be stored securely as environment variables on the production platform.")

print("\n### Conceptual Steps for Configuring Environment Variables (using Heroku as an example):")
print("1.\t **Set Environment Variables:** Use the platform's command-line interface or web dashboard to set environment variables.")
print("\t```bash")
print("\theroku config:set DJANGO_SECRET_KEY='your-very-secret-key'")
print("\theroku config:set GOOGLE_CLIENT_ID='your-prod-google-client-id'")
print("\theroku config:set GOOGLE_CLIENT_SECRET='your-prod-google-client-secret'")
print("\theroku config:set GEMINI_API_KEY='your-prod-gemini-api-key'")
print("\theroku config:set DJANGO_ALLOWED_HOSTS='your-app-name.herokuapp.com,your-custom-domain.com'")
print("\t# DATABASE_URL is typically automatically set by the Heroku Postgres add-on")
print("\t```")
print("\t*(Conceptual commands - replace with your actual keys and domains)*")
print("2.\t **Verify Configuration:** Check that the environment variables are set correctly on the platform.")
print("\t```bash")
print("\theroku config -a your-heroku-app-name")
print("\t```")
print("\t*(Conceptual command)*")
print("3.\t **Access in Django:** Ensure your `settings.py` is configured to read these variables using `os.environ.get()` (as described in Step 3).")

print("\n### Conceptual Steps for Configuring Environment Variables (General):")
print("- Other platforms like AWS or GCP have their own methods for managing environment variables or secrets (e.g., AWS Systems Manager Parameter Store, GCP Secret Manager).")
print("- The principle is to keep secrets out of your codebase and manage them separately in the production environment.")


print("\n## 9. Test the Deployed Application (Conceptual):")
print("After deployment, it's critical to perform thorough testing on the live application to ensure everything works as expected in the production environment.")

print("\n### Conceptual Testing Steps:")
print("1.\t **Access the Deployed Site:** Open your web browser and navigate to the production URL of your application.")
print("2.\t **Perform Core Functionality Tests:**")
print("\t- **Google Login:** Test the Google login flow end-to-end. Verify that you can log in and that your account is correctly recognized.")
print("\t- **Data Input:** Navigate to the input form, enter data, select document types, and submit. Verify that the submission works and redirects correctly.")
print("\t- **Document Generation:** Observe if the document generation process completes. Check logs if needed for errors.")
print("\t- **Document Storage:** Navigate to the document list page. Verify that the newly generated documents appear.")
print("\t- **Document Display:** Click on the generated documents to view their content. Check formatting and accuracy.")
print("3.\t **Test Edge Cases and Error Handling:**")
print("\t- Try submitting invalid or incomplete data in the input form.")
print("\t- (If possible) Simulate API errors or network issues to see how the application responds.")
print("\t- Test with different browsers and devices.")
print("4.\t **Check Static Files:** Verify that CSS, JavaScript, and images are loading correctly.")
print("5.\t **Check Media Files (if implemented):** If users can upload files, test that they are uploaded and served correctly (e.g., from S3).")
print("6.\t **Review Logs:** Check the application logs on the platform for any errors or warnings during testing.")
print("7.\t **Security Checks:** Basic checks like attempting to access restricted pages or other users' data (as outlined in the previous testing plan).")
print("8.\t **Performance Check:** Observe the loading speed and responsiveness of the application.")

print("\n### Tools for Testing:")
print("- **Web Browser Developer Tools:** Console for JavaScript errors, Network tab for resource loading and API calls.")
print("- **Platform Logging:** Heroku logs, AWS CloudWatch, GCP Cloud Logging to monitor application output and errors.")
print("- **Automated Tests:** Run your existing automated test suite against the deployed application if possible (though mocking may need adjustment).")
print("- **Monitoring Tools:** Set up monitoring (e.g., Sentry for error tracking, performance monitoring) for ongoing health checks.")

print("\nConceptual steps for configuring environment variables and testing the deployed application have been outlined.")
print("This completes the steps for deploying the website to a web server.")

"""## Summary:

### Data Analysis Key Findings

*   Arsitektur website dirancang dengan pemisahan frontend (React/Vue), backend (Django/Flask/Node.js), database (PostgreSQL/MySQL), serta integrasi dengan Google Authentication dan Gemini AI API.
*   Skema database konseptual dirancang untuk menyimpan data pengguna dan dokumen yang dihasilkan, mencakup tabel `Users` dan `Documents` dengan relasi one-to-many.
*   Antarmuka pengguna (UI) konseptual meliputi halaman Login, Input Capaian Pembelajaran, dan Manajemen/Tampilan Dokumen, dengan elemen-elemen kunci seperti form input dan daftar dokumen.
*   Integrasi Google Login diusulkan menggunakan pustaka `django-allauth`, memerlukan konfigurasi `settings.py`, `urls.py`, dan pengaturan kredensial OAuth di Google Cloud Console.
*   Integrasi Gemini AI memerlukan instalasi pustaka `google-generativeai` dan penggunaan kunci API yang disimpan secara aman (disarankan menggunakan environment variables).
*   Logika backend untuk pembuatan dokumen melibatkan penerimaan input pengguna, penyusunan prompt spesifik untuk setiap jenis dokumen, pemanggilan API Gemini AI, dan penyimpanan konten yang dihasilkan.
*   Penyimpanan dokumen di database diusulkan dengan membuat instance model `Document` yang terkait dengan pengguna yang login dan menyimpan input serta output AI.
*   Rencana pengujian komprehensif mencakup pengujian fungsionalitas Login, Input Data, Generasi Dokumen, Penyimpanan Data, dan Tampilan Dokumen, baik secara otomatis (menggunakan Django test client dengan mocking) maupun manual (melalui browser).
*   Langkah-langkah deployment meliputi pemilihan platform (contoh: Heroku), pengaturan database produksi (PostgreSQL), konfigurasi setting produksi Django (DEBUG=False, SECRET\_KEY dari env vars, ALLOWED\_HOSTS), penggunaan WSGI server (Gunicorn), penanganan static files (WhiteNoise), deployment kode, menjalankan migrasi database, konfigurasi environment variables, dan pengujian pada lingkungan produksi.

### Insights or Next Steps

*   Langkah selanjutnya adalah mengimplementasikan desain arsitektur, skema database, dan antarmuka pengguna secara konkret menggunakan framework dan teknologi yang dipilih.
*   Fokus utama implementasi backend adalah pada penulisan prompt yang efektif untuk Gemini AI agar menghasilkan dokumen yang relevan dan terstruktur sesuai format kurikulum merdeka, serta memastikan proses penyimpanan dan pengambilan dokumen berjalan lancar.

"""